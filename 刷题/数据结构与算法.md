# 图

##  DFS

### 1、机器人的运动范围

> 题目

地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？



> 思路

注意题目中的移动方式，每次只能移动一格。那么也就是说如果有一次移动中，上下左右四个方向都无法过去，就必须原路返回！

所以就是一道典型的DFS题型。



> 解题特点

DFS中有几个特点

- 记录之前走过的信息（避免重复走）
- 边界明确
- 有一个新格子能否过去的判断条件
- 需要递归



> AC 参考

```python
#coding=utf-8

class Solution:
    def getSum(self, number):
        strNumber = str(number)
        ints = [int(i) for i in list(strNumber)]
        return sum(ints)

    def dfs(self, x, y, threshold, matrix):
        # 1、判断是否越界
        if x<0 or x>=len(matrix) or y<0 or y>=len(matrix[0]):
            return
        
        # 2、在不越界的情况下，判断是否符合条件
        sum_i = self.getSum(x)
        sum_j = self.getSum(y)
        if (sum_i+sum_j>threshold):
            return
        
        # 3、第三个需要返回的是这个点已经visited了
        if matrix[x][y]==1:
            return 
        
        matrix[x][y]=1

        self.dfs(x+1,y,threshold,matrix)
        self.dfs(x,y+1,threshold,matrix)
        self.dfs(x-1,y,threshold,matrix)
        self.dfs(x,y-1,threshold,matrix)


    def movingCount(self, threshold, rows, cols):
        # write code here
        matrix = [[0]*cols for i in range(rows)]
        matrix[0][0]=0
        print(matrix)
        print(matrix[0][1])

        self.dfs(0,0,threshold,matrix)
        print(matrix)
        res=0
        for row in matrix:
            res+=sum(row)
        return res

if __name__ == "__main__":
    res = Solution().movingCount(10, 1, 100)
    print(res)
```

在递归中**先做** `if`不成立的情况，把需要return的情况都列出来后，剩下的就是允许的情况。像这里，有三个不成立的条件，也是一般DFS中常见的三个条件：

- 越界
- 已经访问过了
- 不符合题设的条件

前面两个条件是任务DFS中都存在的，第三个是与题目相关的条件。



## BFS

### 1、Dijkstra 算法

> 算法特点

**BFS、有向图\无向图、单源最短、带权重（大于0）**



> 算法思路

是一个贪心策略：包含了一个顶点集合、一个dis数组

- **顶点集合：**确定了源点到其他点的最短路径后，可以把这些确定的点加入集合
- **dis数组**：保存了源点到其他顶点目前情况下的最短路径



> 实例说明

![image-20200723173836209](数据结构与算法.assets/image-20200723173836209.png)



初始状态下：

- 顶点集合：{v1}

- dis数组：

    ![image-20200723174027927](数据结构与算法.assets/image-20200723174027927.png)

可达不可达是要看顶点集合的，刚开始的顶点就只有v1，即便可以看到v4 可以通过 v1-v3-v4到达，但是v3不在集合中，所以无法使用。



**操作：**

寻找dis数组中最小的数：10。加入对应的顶点v3: {v1, v3}。 说明v1到v3的最短路径现在已经确定了。同时更新v3相关的其他顶点的最短路径。

![image-20200723174349091](数据结构与算法.assets/image-20200723174349091.png)



**重复操作：**

寻找dis数组中最小的数：30。加入对应的顶点v5: {v1, v3, v5}。 说明v1到v5的最短路径现在已经确定了。同时更新v5相关的其他顶点的最短路径。

![image-20200723174458072](数据结构与算法.assets/image-20200723174458072.png)



**重复操作：**

寻找dis数组中最小的数：50。加入对应的顶点v5: {v1, v3, v5, v4}。 说明v1到v4的最短路径现在已经确定了。同时更新v4相关的其他顶点的最短路径。

![image-20200723174612751](数据结构与算法.assets/image-20200723174612751.png)



**重复操作：**

寻找dis数组中最小的数：60。加入对应的顶点v5: {v1, v3, v5, v4, v6}。 说明v1到v6的最短路径现在已经确定了。同时更新v6相关的其他顶点的最短路径。

![image-20200723174637282](数据结构与算法.assets/image-20200723174637282.png)

v1-v2不可达。





# 链表





# 二叉树





# 数学





# 递归



# 动态规划





# 数组



# 字符串





