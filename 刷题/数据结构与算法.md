# 图

##  DFS

### 1、机器人的运动范围

> 题目

地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？



> 思路

注意题目中的移动方式，每次只能移动一格。那么也就是说如果有一次移动中，上下左右四个方向都无法过去，就必须原路返回！

所以就是一道典型的DFS题型。



> 解题特点

DFS中有几个特点

- 记录之前走过的信息（避免重复走）
- 边界明确
- 有一个新格子能否过去的判断条件
- 需要递归



> AC 参考

```python
#coding=utf-8

class Solution:
    def getSum(self, number):
        strNumber = str(number)
        ints = [int(i) for i in list(strNumber)]
        return sum(ints)

    def dfs(self, x, y, threshold, matrix):
        # 1、判断是否越界
        if x<0 or x>=len(matrix) or y<0 or y>=len(matrix[0]):
            return
        
        # 2、在不越界的情况下，判断是否符合条件
        sum_i = self.getSum(x)
        sum_j = self.getSum(y)
        if (sum_i+sum_j>threshold):
            return
        
        # 3、第三个需要返回的是这个点已经visited了
        if matrix[x][y]==1:
            return 
        
        matrix[x][y]=1

        self.dfs(x+1,y,threshold,matrix)
        self.dfs(x,y+1,threshold,matrix)
        self.dfs(x-1,y,threshold,matrix)
        self.dfs(x,y-1,threshold,matrix)


    def movingCount(self, threshold, rows, cols):
        # write code here
        matrix = [[0]*cols for i in range(rows)]
        matrix[0][0]=0
        print(matrix)
        print(matrix[0][1])

        self.dfs(0,0,threshold,matrix)
        print(matrix)
        res=0
        for row in matrix:
            res+=sum(row)
        return res

if __name__ == "__main__":
    res = Solution().movingCount(10, 1, 100)
    print(res)
```

在递归中**先做** `if`不成立的情况，把需要return的情况都列出来后，剩下的就是允许的情况。像这里，有三个不成立的条件，也是一般DFS中常见的三个条件：

- 越界
- 已经访问过了
- 不符合题设的条件

前面两个条件是任务DFS中都存在的，第三个是与题目相关的条件。



### 2、矩阵中路径是否存在

![image-20200729173915310](数据结构与算法.assets/image-20200729173915310.png)



```java
package com.nowcoder.matrix;

import java.util.Arrays;

/**
 * @author Kicc
 * @date 20/7/29 下午 4:02
 */
public class HasPath {

    public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
    {
        // 将一维数组转化成二维矩阵表示
        char[][] myMatrix = switchMatrix(matrix, rows, cols);


        // str 的 下标
        int index = 0;


        int row = 0;
        int col = 0;

        // 出发点可以是矩阵中任意一点
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // 每次出发前，都要把index和访问矩阵重置！
                int [][] visited = new int[rows][cols];
                boolean b = goAround(myMatrix, i, j, visited, str, 0);
                if (b) {
                    return true;
                }
            }
        }

        return false;
    }


    /**
     * dfs过程
     * @param matrix 二维矩阵，不变
     * @param row 遍历的横坐标
     * @param col 遍历的纵坐标
     * @param visited 访问矩阵
     * @param str 字符串 不变
     * @param index 当前的字符串下标
     * @return 是否 存在
     */
    private boolean goAround(char[][] matrix, int row, int col, int[][] visited, char[] str, int index){

        int rows = matrix.length;
        int cols = matrix[0].length;
        
        // 1、判断是否越界
        if (row<0 || row>=rows) {
            return false;
        }
        if (col<0 || col>=cols) {
            return false;
        }

        // 2、是否已经访问过
        if (visited[row][col]==1) {
            return false;
        }

        char curr = str[index];
        // 3、是否符合要求
        if (matrix[row][col]!=curr) {
            return false;
        }

        // 三个条件都通过，就算是访问了当前的元素
        visited[row][col] = 1;

        // 4、判断是否到了字符串尾
        if (curr==matrix[row][col] && index==str.length-1){
            return true;
        }

        // 往前走一步
        int thisStep = index+1;

        //上下左右地走
//        System.out.println("向右走");
        boolean b1 =  goAround(matrix, row, col+1, visited, str, thisStep);
//        System.out.println("向下走");
        boolean b2 =  goAround(matrix, row+1, col, visited, str, thisStep);
//        System.out.println("向上走");
        boolean b3 =  goAround(matrix, row-1, col, visited, str, thisStep);
//        System.out.println("向左走");
        boolean b4 =  goAround(matrix, row, col-1, visited, str, thisStep);


        // 只要存在一个路径有就行
        return b1||b2||b3||b4;

    }


    private char[][] switchMatrix(char [] matrix, int rows, int cols) {
        char[][] myMatrix = new char[rows][cols];

        int count = 0;
        int row = 0;
        int col = 0;

        for (char c : matrix) {
            if (count!=0 && count%cols==0) {
                row++;
                col=0;
            }
            myMatrix[row][col] = c;
            col++;
            count++;
        }
        
        
        return myMatrix;
    }
}
```







## BFS

### 1、Dijkstra 算法

> 算法特点

**BFS、有向图\无向图、单源最短、带权重（大于0）**



> 算法思路

是一个贪心策略：包含了一个顶点集合、一个dis数组

- **顶点集合：**确定了源点到其他点的最短路径后，可以把这些确定的点加入集合
- **dis数组**：保存了源点到其他顶点目前情况下的最短路径



> 实例说明

![image-20200723173836209](数据结构与算法.assets/image-20200723173836209.png)



初始状态下：

- 顶点集合：{v1}

- dis数组：

    ![image-20200723174027927](数据结构与算法.assets/image-20200723174027927.png)

可达不可达是要看顶点集合的，刚开始的顶点就只有v1，即便可以看到v4 可以通过 v1-v3-v4到达，但是v3不在集合中，所以无法使用。



**操作：**

寻找dis数组中最小的数：10。加入对应的顶点v3: {v1, v3}。 说明v1到v3的最短路径现在已经确定了。同时更新v3相关的其他顶点的最短路径。

![image-20200723174349091](数据结构与算法.assets/image-20200723174349091.png)



**重复操作：**

寻找dis数组中最小的数：30。加入对应的顶点v5: {v1, v3, v5}。 说明v1到v5的最短路径现在已经确定了。同时更新v5相关的其他顶点的最短路径。

![image-20200723174458072](数据结构与算法.assets/image-20200723174458072.png)



**重复操作：**

寻找dis数组中最小的数：50。加入对应的顶点v5: {v1, v3, v5, v4}。 说明v1到v4的最短路径现在已经确定了。同时更新v4相关的其他顶点的最短路径。

![image-20200723174612751](数据结构与算法.assets/image-20200723174612751.png)



**重复操作：**

寻找dis数组中最小的数：60。加入对应的顶点v5: {v1, v3, v5, v4, v6}。 说明v1到v6的最短路径现在已经确定了。同时更新v6相关的其他顶点的最短路径。

![image-20200723174637282](数据结构与算法.assets/image-20200723174637282.png)

v1-v2不可达。





# 链表





# 二叉树

### 1、二叉查找树 第k小元素







# 数学





# 递归



# 动态规划





# 数组

### 1、求输入流的中位数

![image-20200729211426013](数据结构与算法.assets/image-20200729211426013.png)

> 题目分析

**为什么要搞一个输入流，而不是直接给一个数组？**

动态性。



> 解法1

得到完整的数组之后，排序，分奇数、偶数。



> 解法2

维护输入流有序，每次都是一个插入排序操作





> 解法3

维护一个大顶堆和一个小顶堆。

- 大顶堆是数组的前半部分**Pre**。存小值，peek() 取出的是最大值。
- 小顶堆是数组的后半部分**Post**。存大值，peek() 取出的是最小值。
- 保证 len(Pre) <= len(Post)



```java
package com.nowcoder.array;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.PriorityQueue;


/**
 * @author Kicc
 * @date 20/7/29 下午 7:59
 */

// 解法1
public class GetMedian {

    private ArrayList<Integer> arrays = new ArrayList<>();

    public void Insert(Integer num) {
        arrays.add(num);
    }

    public Double GetMedian() {
        Collections.sort(arrays);
        for (Integer array : arrays) {
            System.out.println(array);
        }

        Double res = null;
        int length = arrays.size();
        if ((length&1)==0) {
            int little = arrays.get(length/2-1);
            int big = arrays.get(length/2);
            res = (little + (big-little)/2.0);
        } else {
            res = arrays.get(length/2) * 1.0;
        }
        return res;
    }
}

// 解法3
class GetMedian2 {

    // 后半段：小顶堆,默认
    private PriorityQueue<Integer> post = new PriorityQueue<>();

    //前半段：大顶堆
    private PriorityQueue<Integer> pre = new PriorityQueue<>(new Comparator<Integer>() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return o2.compareTo(o1);
        }
    });

    private int count = 0;

    /**
     * 始终保持 len(pre) <= len(post)
     * @param num
     */
    public void Insert(Integer num) {
        count++;

        if ((count&1)==1) {
            // 插入第奇数个，要插入post
            // 但不一定是这个num，可能是pre中取出来的num
            if (!pre.isEmpty() && pre.peek() > num) {
                // 把num放入pre
                // 取出堆顶元素
                pre.offer(num);
                num = pre.poll();
            }
            // 更新后的num插入post
            post.offer(num);
        } else {
            // 插入第偶数个，要插入pre
            // 但不一定是这个num，可能是post中取出来的num
            if (!post.isEmpty() && post.peek() < num) {
                post.offer(num);
                num = post.poll();
            }
            pre.offer(num);
        }
        System.out.println("前半段：");
        System.out.println(pre);
        System.out.println("后半段：");
        System.out.println(post);

    }

    public Double GetMedian() {
        if ((count&1)==1) {
            return post.peek() * 1.0;
        } else {
            return pre.peek() + (post.peek()-pre.peek()) / 2.0;
        }
    }

    public PriorityQueue<Integer> getPre() {
        return pre;
    }

    public PriorityQueue<Integer> getPost() {
        return post;
    }
}
```









# 字符串





# 排序

牢记八大排序的算法、实现、空间复杂度、时间复杂读、稳定性分析。



### 1 简单选择

> 不稳定 【9 2 5 8 5】
>
> 时间复杂度 O(n2)

```java
package com.nowcoder.sort;

/**
 * @author Kicc
 * @date 20/7/26 下午 8:11
 * 简单选择排序的实现
 */
public class EasySort implements Sort {

    /**
     * 每一轮；
     * 选出一组中最大的数放到最后
     * 比如 [3,7,5,9,2,4]
     * 第一轮：
     *     [3,7,5,4,2,9]
     * @param array
     */
    @Override
    public void sort(int [] array) {
        if (array.length==0 || array.length==1) {
            return;
        }

        int count = array.length;
        int max = 0;
        int index = -1;
        for (int i = 0; i < array.length; i++) {

            count = array.length - i;
            index = -1 ;
            max = 0;
            for (int j = 0; j < count; j++) {
                if (array[j]-max>0) {
                    max = array[j] ;
                    index = j;
                }
            }
            if (index!=count-1) {
                // 需要交换
                swap(array, index, array.length-i-1);
            }
        }

    }


}
```



### 2 冒泡排序

> 稳定，相等的元素不会交换
>
> 时间复杂度O(n2)

```java
package com.nowcoder.sort;

/**
 * @author Kicc
 * @date 20/7/26 下午 9:24
 */
public class BubbleSort implements Sort {

    /**
     * 最原始的冒泡排序。
     * 带一点优化的版本：
     *             如果某一次循环已经有序，就break
     *
     * @param array
     */
    @Override
    public void sort(int[] array) {

        int length = array.length;

        //每次循环需要遍历的个数
        int count = 0;

        // 优化的标识
        boolean flag = false;

        for (int i = 0; i < length-1; i++) {

            count = length;
            flag = false;
            for (int j = 0; j < count-1; j++) {
                if (array[j]>array[j+1]) {
                    swap(array, j, j+1);
                    flag = true;
                }
            }
            if (!flag) {
                break;
            }
        }
    }
}
```



### 2.x 鸡尾酒排序

> 鸡尾酒排序最糟或是平均所花费的次数都是O(n²)，但如果序列在一开始已经大部分排序过的话，会接近O(n)。
>
> 稳定

```java
package com.nowcoder.sort;

/**
 * @author Kicc
 * @date 20/7/26 下午 9:32
 * 鸡尾酒排序
 */
public class CockTailSort implements Sort {

    /**
     * 数组中的数字本是无规律的排放，
     * 先找到最小的数字，把他放到第一位，然后找到最大的数字放到最后一位。
     * 然后再找到第二小的数字放到第二位，再找到第二大的数字放到倒数第二位。
     * 以此类推，直到完成排序。
     * @param array
     */
    @Override
    public void sort(int[] array) {
        int length = array.length;

        if (length==0 || length==1) {
            return;
        }

        int i, left = 0, right = length-1;

        while (left<right) {
            
            // 大的往后
            for (i = left; i < right; i++) {
                if (array[i] > array[i+1]) {
                    // 前向大于后向
                    swap(array, i, i+1);
                }
            }
            right--;

            // 小的往前
            for (i = right-1; i > left; i--) {
                if (array[i-1]>array[i]) {
                    // 前向大于后向
                    swap(array, i-1, i);
                }
            }
            left++;
        }

    }
}
```



### 3 插入排序

> 稳定，相等的元素次序不变

将循环退出的条件写到循环里

```java
package com.nowcoder.sort;

/**
 * @author Kicc
 * @date 20/7/26 下午 9:45
 * 插入排序
 */
public class InsertSort implements Sort {

    /**
     * 假定前面的array是有序的，
     * 每次选择一个元素去前面有序数组中找到合适的位置插入
     * @param array
     */
    @Override
    public void sort(int[] array) {

        int length = array.length;

        if (length==0 || length==1) {
            return;
        }

        int i = -1;
        for (int j = 1; j < length; j++) {

            int curr = array[j] ;
            i = j-1;
            // 将循环退出的条件写到循环里
            for (; i >=0 && (array[i]>curr); i--) {
				// 有序列依次后移
                array[i+1] = array[i];
            }
            // 把当前点插入合适位置
            array[i+1] = curr;
        }



    }
}
```





### 4 快速排序

> 不稳定
>
> 递归
>
> 借助partition方法：返回的是pivot应该所在的index



就**空间复杂度**来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度为log2n，其空间复杂度也就为O(logn)，最坏情况，需要进行n‐1递归调用，其空间复杂度为O(n)，平均情况，空间复杂度也为O(logn)。



![image-20200726222922263](数据结构与算法.assets/image-20200726222922263.png)



```java
package com.nowcoder.sort;

/**
 * @author Kicc
 * @date 20/7/26 下午 10:30
 * 快速排序
 */
public class QuickSort implements Sort {


    /**
     * 它的基本思想是：
     * 通过一趟排序将要排序的数据分割成独立的两部分，
     * 其中一部分的所有数据都比另外一部分的所有数据都要小，
     * 然后再按此方法对这两部分数据分别进行快速排序，
     * 整个排序过程可以递归进行，
     * 以此达到整个数据变成有序序列
     * @param array
     */
    @Override
    public void sort(int[] array) {
        int length = array.length;

        if (length==0 || length==1) {
            return;
        }
        quickSort(array, 0, length-1);
    }

    public void quickSort(int[] array, int left, int right) {
        if (left<right) {
            int q  =  partition(array, left, right);
            quickSort(array, left, q-1);
            quickSort(array, q+1, right);
        }
    }

   /**
     * 寻找pivot对应的index
     * 从left到right遍历，以array[right]作为pivot
     * i 从0开始，代表大于pivot的数
     * j 是遍历的计数器，代表小于pivot的数
     * 而遍历过程中，遇到比pivot小的数，swap(array, i, j)
     * 遍历结束后，再把pivot换过去，swap(array, right, i+1)
     * @param array
     * @param left
     * @param right
     * @return pivot交换过后的index
     */
    private int partition(int [] numbers, int left, int right) {
        int x = numbers[right] ;
        int i = left-1;
        for (int j = left; j < right; j++) {
            if (numbers[j] <= x) {
                i+=1;
                swap(numbers, i, j);
            }
        }
        swap(numbers, i+1, right);
        return i+1;
    }
}
```





### 5 希尔排序

> 希尔排序(Shell's Sort)是[插入排序](https://baike.baidu.com/item/插入排序/7214992)的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入[排序算法](https://baike.baidu.com/item/排序算法/5399605)的一种更高效的改进版本。希尔排序是非稳定排序算法。
>
> 时间复杂度 O(nlog2n)



希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，[算法](https://baike.baidu.com/item/算法/209025)便终止。



![image-20200726234254030](数据结构与算法.assets/image-20200726234254030.png)



希尔排序是基于插入排序的以下两点性质而**提出改进方法**的：

1. 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。
2. 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。



**时间复杂度情况如下：**（n指待排序序列长度）
 **1) 最好情况：**序列是正序排列，在这种情况下，需要进行的比较操作需（n-1）次。后移赋值操作为0次。即O(n)
 **2) 最坏情况：**O(nlog2n)。
 **3) 渐进时间复杂度（平均时间复杂度）：**O(nlog2n)



![img](数据结构与算法.assets/6095354-ff984d80dbc0455f.png)



第一次增量 = length / 2；

第二次增量 = 第一次增量 / 2；

第三次增量 = 第二次增量 / 4；

...

```java
package com.nowcoder.sort;

/**
 * @author Kicc
 * @date 20/7/27 上午 12:07
 * 希尔排序
 */
public class ShellSort implements Sort {

    /**
     * 三个for
     * 1、gap的变化：for(gap=n/2; gap>0; gap/=2)
     * 2、n=gap开始的自增，表示每个分组 for(n=gap;n<length;n++)；对应插入排序 for(n=1;n<length;n++)
     * 3、每个分组下的插入排序 for(j=n-gap; j>=0 && (curr<array[j]); j+=gap)
     * 对应 插入排序 for(j=n-1;;j+=1)
     * @param array
     */
    @Override
    public void sort(int[] array) {
        int length = array.length;

        if (length==0 || length==1) {
            return;
        }

        for (int gap = length/2; gap > 0 ; gap/=2) {
            
            // 里边两个for循环和插入排序是一样的，步长变成了gap而已
            int j;
            for (int i = gap; i < length; i++) {

                int curr = array[i];
                j = i-gap;
                for (; j >=0 && (curr<array[j]) ; j-=gap) {
                    array[j+gap] = array[j];
                }
                array[j+gap] = curr;
            }
        }
    }
}
```

​	 ![image-20200727002848053](数据结构与算法.assets/image-20200727002848053.png)

代码中的 `i`的变化，因为分成了多组，各组之间是交替执行的。这个跟插入排序理解起来有所不同。不过本质都一样的。









### 6 堆排序

> 不稳定



> 什么是堆

- 满足父节点始终大于\小于左右子树的完全二叉树。



> 一棵二叉树如何调整为最大堆

![cf22273fb1a2e327e317d9cbc23cefbd.png](数据结构与算法.assets/Image.png)

因为是一棵完全二叉树，所以从最后一个叶子节点的父节点开始向上遍历：

- 如果父节点的值小于子节点：交换
- 交换过后，新的父节点小于下面的子节点：继续交换
- 得到最大值的堆顶后交换 swap(array, 0, length-i)



> 完成堆排序的三个方法

1. init：初始化方法，构造一个最大堆
2. adjust(array, index, length)：
    1. array是需要排序的数组
    2. index是当前的节点的index，如图上红色的节点
    3. length是需要排序的长度，并不是整个array都需要进行排序



```java
package com.nowcoder.sort;

/**
 * @author Kicc
 * @date 20/7/27 上午 11:39
 * 堆排序
 */
public class HeapSort implements Sort {

    /**
     * 所有的过程都用数组表示就可以了，不需要转为二叉树的形式
     * 分为三个部分：
     * 1、初始化：将数组（二叉树）初始化为最大堆，调用了adjust方法
     * 2、调整：adjust(array, index, length)：基础的调整方法
     * 3、排序：for n in range(length-1, -1, -1)
     * @param array
     */
    @Override
    public void sort(int[] array) {
        heapSort(array);
    }


    /**
     * 转为最大堆
     * @param array
     */
    private void init(int[] array) {
        int length = array.length;
        int father_index = (length-1)/2;

        for (int i = father_index; i >= 0; i--) {
            adjust(array, i, length);
        }
    }

    /**
     * 为从(length/2)开始的每个节点进行堆操作，单个函数只针对一次调整
     * @param array
     * @param index 红色的节点
     * @param length 需要排序的array长度 比最大的下标大1
     */
    private void adjust(int [] array, int index, int length) {
        // index的左子树
        int left = 2*index+1;
        if (left+1>length) {
            // 超出了需要排序的范围
            return;
        }
        int right = left+1;

        int bigger = -1;
        // 挑选max(left, right)
        if (right<=length-1) {
            // right最大为length-1
            if (array[left]>array[right]) {
                bigger = left;
            } else {
                bigger = right;
            }
        } else {
            // 否则没有right
            bigger = left;
        }

        // bigger与index比较
        if (array[index]>=array[bigger]) {
            return;
        } else {
            swap(array, index, bigger);
            adjust(array, bigger, length);
        }

    }

    /**
     * 1、初始化 构造最大堆
     * 2、swap(array, 0, i)
     * 3、adjust(array, 0, i)：自上而下的调整
     * @param array
     */
    private void heapSort(int [] array) {
        init(array);
        int length = array.length;

        for (int i = length-1; i >= 0 ; i--) {
            swap(array, i, 0);
            // 自上而下的调整，从0开始
            adjust(array, 0, i);
        }
    }



}
```



只有初始化的第一次需要 

![image-20200727125718766](数据结构与算法.assets/image-20200727125718766.png)

从 (length-1)/2到0过一遍，之后的每一次从0开始就可以

![image-20200727125757055](数据结构与算法.assets/image-20200727125757055.png)







### 7 归并排序

> 稳定的，两个有序的组合成一个有序的组过程中不会破坏其稳定性
>
> 时间复杂度



```java
package com.nowcoder.sort;

/**
 * @author Kicc
 * @date 20/7/27 下午 12:59
 */
public class MergeSort implements Sort {

    /**
     *
     * @param array
     */
    @Override
    public void sort(int[] array) {

        int length = array.length;

        if (length==0 || length==1) {
            return;
        }

        mergeSort(array,0, length-1);
    }


    private void mergeSort(int[] array, int left, int right) {
        if (left>=right) {
            return;
        }

        int mid = left + (right-left)/2;
        mergeSort(array, left, mid);
        mergeSort(array, mid+1, right);
        merge(array, left, mid, right);
    }

    /**
     * 合并 array[left:mid] array[mid+1:right]
     * 两个数组都是有序的
     * @param array
     * @param left
     * @param mid 
     * @param right
     */
    private void merge(int [] array, int left, int mid, int right) {
        int l = left;
        int r = mid+1;
        int [] temp = new int[right-left+1];
        int index = 0;
        while (l<=mid && r<=right) {
            if (array[l]<array[r]) {
                temp[index++]=array[l];
                l++;
            } else {
                temp[index++]=array[r];
                r++;
            }
        }
        if (r<=right) {
            while (r<=right) {
                temp[index++] = array[r];
                r++;
            }
        }
        if (l<=mid) {
            while (l<=mid) {
                temp[index++] = array[l];
                l++;
            }
        }

        // 把临时数组的值赋给array
        for (int i = left; i <= right; i++) {
            array[i] = temp[i-left];
        }
    }
}
```







### 8 基数排序

> 稳定
>
> 时间空间复杂度 跟其他的不一样







### 总结

![img](数据结构与算法.assets/aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTEvMTkvMTM1MzI5MjU4N18yMjc5LnBuZw)