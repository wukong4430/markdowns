# 图

##  DFS

### 1、机器人的运动范围

> 题目

地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？



> 思路

注意题目中的移动方式，每次只能移动一格。那么也就是说如果有一次移动中，上下左右四个方向都无法过去，就必须原路返回！

所以就是一道典型的DFS题型。



> 解题特点

DFS中有几个特点

- 记录之前走过的信息（避免重复走）
- 边界明确
- 有一个新格子能否过去的判断条件
- 需要递归



> AC 参考

```python
#coding=utf-8

class Solution:
    def getSum(self, number):
        strNumber = str(number)
        ints = [int(i) for i in list(strNumber)]
        return sum(ints)

    def dfs(self, x, y, threshold, matrix):
        # 1、判断是否越界
        if x<0 or x>=len(matrix) or y<0 or y>=len(matrix[0]):
            return
        
        # 2、在不越界的情况下，判断是否符合条件
        sum_i = self.getSum(x)
        sum_j = self.getSum(y)
        if (sum_i+sum_j>threshold):
            return
        
        # 3、第三个需要返回的是这个点已经visited了
        if matrix[x][y]==1:
            return 
        
        matrix[x][y]=1

        self.dfs(x+1,y,threshold,matrix)
        self.dfs(x,y+1,threshold,matrix)
        self.dfs(x-1,y,threshold,matrix)
        self.dfs(x,y-1,threshold,matrix)


    def movingCount(self, threshold, rows, cols):
        # write code here
        matrix = [[0]*cols for i in range(rows)]
        matrix[0][0]=0
        print(matrix)
        print(matrix[0][1])

        self.dfs(0,0,threshold,matrix)
        print(matrix)
        res=0
        for row in matrix:
            res+=sum(row)
        return res

if __name__ == "__main__":
    res = Solution().movingCount(10, 1, 100)
    print(res)
```

在递归中**先做** `if`不成立的情况，把需要return的情况都列出来后，剩下的就是允许的情况。像这里，有三个不成立的条件，也是一般DFS中常见的三个条件：

- 越界
- 已经访问过了
- 不符合题设的条件

前面两个条件是任务DFS中都存在的，第三个是与题目相关的条件。



## BFS

### 1、Dijkstra 算法

> 算法特点

**BFS、有向图\无向图、单源最短、带权重（大于0）**



> 算法思路

是一个贪心策略：包含了一个顶点集合、一个dis数组

- **顶点集合：**确定了源点到其他点的最短路径后，可以把这些确定的点加入集合
- **dis数组**：保存了源点到其他顶点目前情况下的最短路径



> 实例说明

![image-20200723173836209](数据结构与算法.assets/image-20200723173836209.png)



初始状态下：

- 顶点集合：{v1}

- dis数组：

    ![image-20200723174027927](数据结构与算法.assets/image-20200723174027927.png)

可达不可达是要看顶点集合的，刚开始的顶点就只有v1，即便可以看到v4 可以通过 v1-v3-v4到达，但是v3不在集合中，所以无法使用。



**操作：**

寻找dis数组中最小的数：10。加入对应的顶点v3: {v1, v3}。 说明v1到v3的最短路径现在已经确定了。同时更新v3相关的其他顶点的最短路径。

![image-20200723174349091](数据结构与算法.assets/image-20200723174349091.png)



**重复操作：**

寻找dis数组中最小的数：30。加入对应的顶点v5: {v1, v3, v5}。 说明v1到v5的最短路径现在已经确定了。同时更新v5相关的其他顶点的最短路径。

![image-20200723174458072](数据结构与算法.assets/image-20200723174458072.png)



**重复操作：**

寻找dis数组中最小的数：50。加入对应的顶点v5: {v1, v3, v5, v4}。 说明v1到v4的最短路径现在已经确定了。同时更新v4相关的其他顶点的最短路径。

![image-20200723174612751](数据结构与算法.assets/image-20200723174612751.png)



**重复操作：**

寻找dis数组中最小的数：60。加入对应的顶点v5: {v1, v3, v5, v4, v6}。 说明v1到v6的最短路径现在已经确定了。同时更新v6相关的其他顶点的最短路径。

![image-20200723174637282](数据结构与算法.assets/image-20200723174637282.png)

v1-v2不可达。





# 链表





# 二叉树





# 数学





# 递归



# 动态规划





# 数组



# 字符串





# 排序

牢记八大排序的算法、实现、空间复杂度、时间复杂读、稳定性分析。



### 1 简单选择

> 不稳定 【9 2 5 8 5】
>
> 时间复杂度 O(n2)

```java
package com.nowcoder.sort;

/**
 * @author Kicc
 * @date 20/7/26 下午 8:11
 * 简单选择排序的实现
 */
public class EasySort implements Sort {

    /**
     * 每一轮；
     * 选出一组中最大的数放到最后
     * 比如 [3,7,5,9,2,4]
     * 第一轮：
     *     [3,7,5,4,2,9]
     * @param array
     */
    @Override
    public void sort(int [] array) {
        if (array.length==0 || array.length==1) {
            return;
        }

        int count = array.length;
        int max = 0;
        int index = -1;
        for (int i = 0; i < array.length; i++) {

            count = array.length - i;
            index = -1 ;
            max = 0;
            for (int j = 0; j < count; j++) {
                if (array[j]-max>0) {
                    max = array[j] ;
                    index = j;
                }
            }
            if (index!=count-1) {
                // 需要交换
                swap(array, index, array.length-i-1);
            }
        }

    }


}
```



### 2 冒泡排序

> 稳定，相等的元素不会交换
>
> 时间复杂度O(n2)

```java
package com.nowcoder.sort;

/**
 * @author Kicc
 * @date 20/7/26 下午 9:24
 */
public class BubbleSort implements Sort {

    /**
     * 最原始的冒泡排序。
     * 带一点优化的版本：
     *             如果某一次循环已经有序，就break
     *
     * @param array
     */
    @Override
    public void sort(int[] array) {

        int length = array.length;

        //每次循环需要遍历的个数
        int count = 0;

        // 优化的标识
        boolean flag = false;

        for (int i = 0; i < length-1; i++) {

            count = length;
            flag = false;
            for (int j = 0; j < count-1; j++) {
                if (array[j]>array[j+1]) {
                    swap(array, j, j+1);
                    flag = true;
                }
            }
            if (!flag) {
                break;
            }
        }
    }
}
```



### 2.x 鸡尾酒排序

> 鸡尾酒排序最糟或是平均所花费的次数都是O(n²)，但如果序列在一开始已经大部分排序过的话，会接近O(n)。
>
> 稳定

```java
package com.nowcoder.sort;

/**
 * @author Kicc
 * @date 20/7/26 下午 9:32
 * 鸡尾酒排序
 */
public class CockTailSort implements Sort {

    /**
     * 数组中的数字本是无规律的排放，
     * 先找到最小的数字，把他放到第一位，然后找到最大的数字放到最后一位。
     * 然后再找到第二小的数字放到第二位，再找到第二大的数字放到倒数第二位。
     * 以此类推，直到完成排序。
     * @param array
     */
    @Override
    public void sort(int[] array) {
        int length = array.length;

        if (length==0 || length==1) {
            return;
        }

        int i, left = 0, right = length-1;

        while (left<right) {
            
            // 大的往后
            for (i = left; i < right; i++) {
                if (array[i] > array[i+1]) {
                    // 前向大于后向
                    swap(array, i, i+1);
                }
            }
            right--;

            // 小的往前
            for (i = right-1; i > left; i--) {
                if (array[i-1]>array[i]) {
                    // 前向大于后向
                    swap(array, i-1, i);
                }
            }
            left++;
        }

    }
}
```



### 3 插入排序

> 稳定，相等的元素次序不变

将循环退出的条件写到循环里

```java
package com.nowcoder.sort;

/**
 * @author Kicc
 * @date 20/7/26 下午 9:45
 * 插入排序
 */
public class InsertSort implements Sort {

    /**
     * 假定前面的array是有序的，
     * 每次选择一个元素去前面有序数组中找到合适的位置插入
     * @param array
     */
    @Override
    public void sort(int[] array) {

        int length = array.length;

        if (length==0 || length==1) {
            return;
        }

        int i = -1;
        for (int j = 1; j < length; j++) {

            int curr = array[j] ;
            i = j-1;
            // 将循环退出的条件写到循环里
            for (; i >=0 && (array[i]>curr); i--) {
				// 有序列依次后移
                array[i+1] = array[i];
            }
            // 把当前点插入合适位置
            array[i+1] = curr;
        }



    }
}
```





### 4 快速排序

> 不稳定
>
> 递归
>
> 借助partition方法：返回的是pivot应该所在的index

![image-20200726222922263](数据结构与算法.assets/image-20200726222922263.png)



```java
package com.nowcoder.sort;

/**
 * @author Kicc
 * @date 20/7/26 下午 10:30
 * 快速排序
 */
public class QuickSort implements Sort {


    /**
     * 它的基本思想是：
     * 通过一趟排序将要排序的数据分割成独立的两部分，
     * 其中一部分的所有数据都比另外一部分的所有数据都要小，
     * 然后再按此方法对这两部分数据分别进行快速排序，
     * 整个排序过程可以递归进行，
     * 以此达到整个数据变成有序序列
     * @param array
     */
    @Override
    public void sort(int[] array) {
        int length = array.length;

        if (length==0 || length==1) {
            return;
        }
        quickSort(array, 0, length-1);
    }

    public void quickSort(int[] array, int left, int right) {
        if (left<right) {
            int q  =  partition(array, left, right);
            quickSort(array, left, q-1);
            quickSort(array, q+1, right);
        }
    }

   /**
     * 寻找pivot对应的index
     * 从left到right遍历，以array[right]作为pivot
     * i 从0开始，代表大于pivot的数
     * j 是遍历的计数器，代表小于pivot的数
     * 而遍历过程中，遇到比pivot小的数，swap(array, i, j)
     * 遍历结束后，再把pivot换过去，swap(array, right, i+1)
     * @param array
     * @param left
     * @param right
     * @return pivot交换过后的index
     */
    private int partition(int [] numbers, int left, int right) {
        int x = numbers[right] ;
        int i = left-1;
        for (int j = left; j < right; j++) {
            if (numbers[j] <= x) {
                i+=1;
                swap(numbers, i, j);
            }
        }
        swap(numbers, i+1, right);
        return i+1;
    }
}
```

