# 基础知识点



### 二进制

> 为什么计算机内部是用二进制？

- 二进制和十进制的转化很方便。
- 原始的机器是打孔的，以0 和 1进行区分
- 用二进制的位计算速度非常快
- 网络中传输的数据都是二进制的bit流



> 为什么计算出从0开始？

迪杰斯特拉提到，从0开始计数可以更好的表示范围。因为计算机中传递都都是二进制的bit流， 0 1 两个数字只需要一个位，0 1 2 3 只需要2个位，如果从1开始，1 2需要两个位，1 2 3 4需要2个bit。这样就乱了。

| 二进制 从0 开始 | 从1开始  |
| --------------- | -------- |
| 0 = 0000        | 1 = 0001 |
| 1 = 0001        | 2 = 0010 |
| 2 = 0010        | 3 = 0011 |
| 3 = 0011        | 4 = 0100 |
| 4 = 0100        | 5 = 0101 |
|                 |          |

> > 从零开始编号的阵列不会造成索引范围重叠，是最好的表示方法，从零开始暗示与实数同样的[开，半开和闭区间](https://zh.wikipedia.org/wiki/區間)。Dijkstra偏好这惯例的细节以空序列说明，它可以用更自然的（a≤i<a？）不等式来表示，相较于用闭合“区间”的（a≤i≤(a-1)？）不等式。而且以自然的半开“区间”不等式来看，子序列的长度等于上界减去下界（a≤i<b给出(b-a)的i可能值，其中的a，b，i都是自然数）



#### 补码、源码、反码、移码

> 计算机中的数字都用补码表示
>
> 注意：0的补码反码都为0.

**原码**：

- 最高位：表示正负
- 其他位：数字的绝对值

**补码**：

- 如果是正数：和原码一致
- 如果是负数：原码 -> 反码 ->  +1

**反码**：

- 如果是正数：和原码一致
- 如果是负数：原码基础上，符号位不变，其他位取反

**移码**：

- 在补码的基础上，对符号位取反 ？ （有啥意思）









# 网络



### IP地址段

> 网络地址



![image-20200730205421816](计算机基础.assets/image-20200730205421816.png)



- A段网络：1-126
- B段网络：128-191
- C段网络：192-223

C段网络还可以再分，目的是为了节省主机。不造成浪费。

- 将8位主机段分成2份，那么子网的掩码是 `255.255.255.128`, 可用主机号：1-126/129-254。 0 和128代表各个子段的**网关**，127和255代表各个子段的**广播地址**。
- 将8位主机段分成4份，那么子网的掩码是 `255.255.255.192`, 可用主机号：1-62/65-126/129-190/193-254。 0、64、128、192代表各个子段的**网关**，63、127、191、255代表各个子段的**广播地址**。

