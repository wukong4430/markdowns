# IO



## 1、IO的输入输出

IO的存在是为了数据的交互。通过计算机内部的数据线传输数据，也就是 bit、字节。

- 读入数据：数据从外流入内存。
- 输出数据：数据从内存流向其他设备。



## 2、多种IO流



学习IO流，需要针对于某一个输入输出设备。

### 硬盘

硬盘作为最常见的设备在程序中随处可见。由于Java程序运行在JVM上，程序可见的并不是硬盘本身，而是由操作系统提供的文件系统。



### 标准 输入输出

System.in

System.out



### 顶层API的由来

虽然我们大部分操作都是操作文件系统，但是要明白IO流的概念不仅仅局限在操作文件上。我们的编程语言是要能操作所有的输入输出，因此，API提供了两个顶层抽象类，用来表示操作所有的输出输出：InputStream，OutputStream。



### 文件流

字节流是最最基本的流”，这句话的由来就是因为计算机底层传递的就是字节。那么，当我们要操作文件的时候，就需要具体的对文件系统操作的IO实现类，于是我们需要学习FileInputStream和FileOutputStream，它们是文件输入输出字节流。



## 3、带缓冲区的IO



### 出现原因

学了文件IO字节流之后，我们会发现原始的字节流对象用起来没那么高效，因为每个读或写请求都由底层操作系统处理，这些请求往往会触发磁盘访问、网络活动或其他一些相对昂贵的操作。



**不带缓冲区的对象，只能一个字节一个字节的读**，每次都调用底层的操作系统API，非常低效，而带缓冲区的流对象，可以一次读一个缓冲区，缓冲区空了才去调用一次底层API，这就能大大提高效率。

于是有了：**BufferedInputStream**和**BufferedOutputSteam**。





## 4、文件类型和字符处理

说到操作文件，就不得不提到文件的分类和编码格式。文件分为二进制文件和文本文件。对于文本文件，人类可读；对于二进制文件，计算机可读。

因此，人们需要有能够处理字符的类，或者说这个类提供一个功能：**就是把输入的字节转成字符，把要输出的字符转成计算机可以识别的字节。**

于是有了：两个转换流：**InputStreamReader**和**OutputStreamWriter**。

**InputStreamReader**： 字节流 ==> 字符流

**OutputStreamWriter**：字符流==>字节流



## 字符流

- Reader： 用于读取字符流的抽象类。子类必须实现的方法只有 read(char[], int, int) 和 close()。
    - BufferedReader ：从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。
    - LineNumberReader ：跟踪行号的缓冲字符输入流。此类定义了方法 setLineNumber(int) 和getLineNumber()，它们可分别用于设置和获取当前行号。
    - InputStreamReader ：是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。
- Writer： 写入字符流的抽象类。子类必须实现的方法仅有 write(char[], int, int)、flush() 和 close()。
    - BufferedWriter： ：将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。
    - OutputStreamWriter ：是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。
    - FileWriter： ：用来写入字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的。要自己指定这些值，可以先在 FileOutputStream 上构造一个 OutputStreamWriter。



## 4、





## 5、总结

- 字节流是基础。所有的流都是建立在字节流的基础之上。但是字节流做不了高级的工作。

- 为了简化日常常用的文件操作，API中又FileReader和FileWriter流对象，直接完场字符流和字节流的转换。

- 为了提高效率，将一字节读取的流加上缓冲区，实现高效的字符、节流。