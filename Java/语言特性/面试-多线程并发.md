****

# 多线程基础

**看看CPU的主要组成**

![image-20200728145141446](面试-多线程并发.assets/image-20200728145141446.png)



> 什么是线程和进程？

**线程：**进程中负责程序执行的执行单元。一个进程中至少有一个线程。

**多线程：**解决多任务同时执行的需求，合理使用CPU资源。多线程的运行是根据CPU切换完成，如何切换由CPU决定，因此多线程运行具有不确定性。

**线程池：**基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多**(未死亡)**的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以**避免反复创建线程对象所带来的性能开销**，节省了系统的资源。



> 和进程的区别？

一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。 Windows中的QQ、Chrome、Idea都是一个进程。

线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程**共享一片相同**的内存空间。

别把它和栈内存搞混，**每个线程都拥有单独的栈内存**用来存储本地数据。



> JVM级别的线程和OS中的线程关系

**Hotspot中的实现方式：**

- 内核线程与JVM线程 1：1. 
- jdk1.2之前， synchronized(o)  由OS帮忙管理线程：属于**重量级锁** （==与之相对应的就是轻量级锁，不需要OS的帮忙==）
- 发展到协程后，在JVM内部有虚拟的寄存器，虚拟的PC，管理用户空间的线程。属于轻量级的线程。









> Runnable 和 Thread 都能实现线程，用哪一个？

Java不支持多继承，但是可以实现多个接口。如果需要继承其他类，就使用Runnable



> Runnable 和 Callable 区别？

它们的主要区别是 Callable 的 call() 方法可以返回值和抛出异常，而 Runnable 的 run() 方法没有这些功能。Callable 可以返回装载有计算结果的 Future 对象。





> 线程池的优点

1）避免线程的创建和销毁带来的性能开销。
2）避免大量的线程间因互相抢占系统资源导致的阻塞现象。
3｝能够对线程进行简单的管理并提供定时执行、间隔执行等功能。







## 并发

同一个对象被多个线程操作。

### 线程不安全



- 多个线程同时操作一个对象，产生线程不安全现象

假设这里是买火车票的情况

```java
public class ThreadTest1 implements Runnable {

    private int ticketNum = 10;

    @lombok.SneakyThrows
    public void run() {

        while (true) {
            if (ticketNum<=0) {
                break;
            }
            Thread.sleep(200);

            System.out.println(Thread.currentThread().getName() + "-->拿到了第"+ticketNum-- + "张票");

        }
    }

}
```



测试

```java
public class MyTest {

    public static void main(String[] args) {
        ThreadTest1 ticket = new ThreadTest1();

        // 多线程操作同一个对象，出现资源被重复使用的现象
        new Thread(ticket, "小明").start();
        new Thread(ticket, "老师").start();
        new Thread(ticket, "黄牛").start();
    }

}
```

```
小明-->拿到了第10张票
黄牛-->拿到了第9张票
老师-->拿到了第8张票
老师-->拿到了第7张票
小明-->拿到了第7张票
黄牛-->拿到了第6张票
老师-->拿到了第4张票
黄牛-->拿到了第3张票
小明-->拿到了第5张票
小明-->拿到了第2张票
黄牛-->拿到了第0张票
老师-->拿到了第1张票
```

可以看到，同一张票有多次被取到的情况。



## 线程状态



### 死亡

如何停止一个线程？

- 不推荐JDK提供的 stop(), destroy()方法。【已废弃】
- 推荐线程自己停下来。
- 建议使用一个标志位进行终止变量。当flag=false，则线程终止。



```java
public class TestStop implements Runnable {
    private boolean flag = true;

    public void run() {
        int i=0;
        while (flag) {
            System.out.println("run .... Thread" + i++);
        }
    }


    public void stop() {
        this.flag = false;
    }
}
```



### 创建





### 就绪

当线程调用start()方法时，线程就进入了就绪状态。





### 运行





### 阻塞

- 线程休眠
    - sleep(millis)：模拟网络延迟，放大问题的发生性。**不会释放锁。**
- 线程礼让
    - yield：A线程执行yield，并不能保证A不再执行。礼让不一定成功。



### 守护线程

```java
public class TestDeamon {

    public static void main(String[] args) {
        God god = new God();
        You you = new You();

        Thread thread = new Thread(god);
        thread.setDaemon(true);
        thread.start(); // 上帝守护线程启动，JVM不需要等待其结束
        
        new Thread(you).start();
    }

}


class God implements Runnable {

    public void run() {
        while (true) {
            System.out.println("God bless you");
        }
    }
}

class You implements Runnable {

    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("你一直开心的活着, 第" + i + "年");
        }
        System.out.println(" ========= go to heaven.=========");
    }
}
```

- 用thread.setDeamon(true) 将一个用户线程设置为守护线程。JVM就不需要等待他执行完毕。只要其他的用户线程执行完毕，那么程序就可以退出了。**（实际中推出前还守护线程还执行了一会）**



## 状态时间的转移



![img](面试-多线程并发.assets/20150309140927553)

1、新建状态（New）：新创建了一个线程对象。
2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)
（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）
5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。



> 其他四种的状态都比较好理解，阻塞状态需要多注意点。尤其是wait和同步 synchronized





## 线程调度



常用调度方法介绍



### Thread.sleep(long millis)  

线程睡眠：使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。



### Object.wait() 

线程等待：导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。



### Thread.yield()

> 我让了，你能不能拿到看你自己的本事了

线程让步：**暂停**当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。

 **yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。**

因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序**再次选中**。

```java
class ThreadYield extends Thread{
    public ThreadYield(String name) {
        super(name);
    }
 
    @Override
    public void run() {
        for (int i = 1; i <= 50; i++) {
            System.out.println("" + this.getName() + "-----" + i);
            // 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行）
            if (i ==30) {
                this.yield();
            }
        }
	
}
}
 
public class Main {
 
	public static void main(String[] args) {
		
		ThreadYield yt1 = new ThreadYield("张三");
    	ThreadYield yt2 = new ThreadYield("李四");
        yt1.start();
        yt2.start();
	}
 
}
```

运行结果：

第一种情况：李四（线程）当执行到30时会CPU时间让掉，这时张三（线程）抢到CPU时间并执行。

第二种情况：李四（线程）当执行到30时会CPU时间让掉，这时李四（线程）抢到CPU时间并执行。

sleep能保证在规定的时间内，当前线程肯定不执行。

yield是将当前线程的运行状态终止，重新放入runnable状态。如果这时候恰好又竞争到了执行，会被立即执行。

yield的 退让 指只会让给优先级 >= 自身的线程，如果没有比自身线程优先级高的，则会继续执行。



### Thread.join()

线程加入：等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。 

```java
@Test
public void test2() throws InterruptedException {
    Thread t1 = new Thread(new MyThread2("线程3"));
    Thread t2 = new Thread(new MyThread2("线程4"));
    t1.start();
    t1.join();
    System.out.println("主线程");

    t2.start();

}
}
```

```
线程3运行  :  0
线程3运行  :  1
线程3运行  :  2
线程3运行  :  3
线程3运行  :  4
主线程
线程4运行  :  0
线程4运行  :  1
线程4运行  :  2
线程4运行  :  3
线程4运行  :  4
```



比如在main线程中调用了t1.join()，那么输出“主线程”的语句必须等待t1结束后才能得到cpu的执行。

```java
@Test
public void test2() throws InterruptedException {
    System.out.println("主线程");

    Thread t1 = new Thread(new MyThread2("线程3"));
    Thread t2 = new Thread(new MyThread2("线程4"));
    t1.start();
    t1.join();

    t2.start();

}
}
```

```
主线程
线程3运行  :  0
线程3运行  :  1
线程3运行  :  2
线程3运行  :  3
线程3运行  :  4
线程4运行  :  0
线程4运行  :  1
线程4运行  :  2
线程4运行  :  3
线程4运行  :  4
```



​		**为什么要用join方法？**

​		在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线		程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子		线程执行完成之后再结束，这个时候就要用到join()方法了。



### Object.notify(all)

线程唤醒：唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。

线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。





## 线程同步

> 队列+锁



### 不同步的情况

错误的范例：银行取钱

```java
public class UnsafeBank {
    public static void main(String[] args) {
        Account account = new Account(100, "度假基金");

        Withdraw kai = new Withdraw(account, 50, "Kai");
        Withdraw lei = new Withdraw(account, 100, "Lei");

        kai.start();
        lei.start();
    }
}


class Account {
    int money;
    String name;

    public Account(int money, String name) {
        this.money = money;
        this.name = name;
    }

    public int getMoney() {
        return money;
    }

    public void setMoney(int money) {
        this.money = money;
    }
}


class Withdraw extends Thread {

    private Account account;
    private int withdrawMoney;
    private int nowMoney;

    public Withdraw(Account account, int withdrawMoney, String name) {
        super(name);
        this.account = account;
        this.withdrawMoney = withdrawMoney;
    }

    @SneakyThrows
    @Override
    public void run() {
        // 判断有没有钱
        if (account.money-withdrawMoney<0) {
            System.out.println(Thread.currentThread().getName() + "钱不够了，取不了");
        }

        Thread.sleep(1000);

        //卡内余额 = 原本的钱 - withDrawMoney
        account.money = account.money-withdrawMoney;
        //你手里的钱
        nowMoney = nowMoney+withdrawMoney;

        System.out.println(account.name + "余额为：" + account.money);
        System.out.println(this.getName() + "手里的钱为：" + nowMoney);

    }

}
```

```
度假基金余额为：0
度假基金余额为：0
Lei手里的钱为：100
Kai手里的钱为：50

度假基金余额为：50
度假基金余额为：50
Kai手里的钱为：50
Lei手里的钱为：100

度假基金余额为：-50
度假基金余额为：-50
Kai手里的钱为：50
Lei手里的钱为：100
```



这三种输出都有可能发生。





### synchronized

在代码中，分为同步方法和同步块。

对一个大的方法使用同步，有可能会极大地影响性能：

- 一个方法中，可能分为只读和其他操作代码。只读的代码不需要进行同步。（对其加了同步就造成了资源的浪费）
- 用作方法的关键字时，默认锁this对象。

```java
@SneakyThrows
@Override
public synchronized void run() {
    // 判断有没有钱
    if (account.money-withdrawMoney<0) {
        System.out.println(Thread.currentThread().getName() + "钱不够了，取不了");
    }

    Thread.sleep(1000);

    //卡内余额 = 原本的钱 - withDrawMoney
    account.money = account.money-withdrawMoney;
    //你手里的钱
    nowMoney = nowMoney+withdrawMoney;

    System.out.println(account.name + "余额为：" + account.money);
    System.out.println(this.getName() + "手里的钱为：" + nowMoney);

}
```


对run方法进行加锁后，取钱出错的问题依然存在，这是因为：

- 加锁的对象是this，而取钱的对象应该是account。所以锁无效
- 形象的说，两个人去银行取钱，我把银行锁了（而不是账户），那有区别吗？
- 应该改为：

```java
class Withdraw extends Thread {

    private Account account;
    private int withdrawMoney;
    private int nowMoney;

    public Withdraw(Account account, int withdrawMoney, String name) {
        super(name);
        this.account = account;
        this.withdrawMoney = withdrawMoney;
    }

    @SneakyThrows
    @Override
    public void run() {

        synchronized (account) {

            // 判断有没有钱
            if (account.money - withdrawMoney < 0) {
                System.out.println(Thread.currentThread().getName() + "钱不够了，取不了");
                return;
            }

            Thread.sleep(100);

            //卡内余额 = 原本的钱 - withDrawMoney
            account.money = account.money - withdrawMoney;
            //你手里的钱
            nowMoney = nowMoney + withdrawMoney;

            System.out.println(account.name + "余额为：" + account.money);
            System.out.println(this.getName() + "手里的钱为：" + nowMoney);
        }

    }

}
```

> P20











## Lambda 表达式



### 为什么要使用

- 避免匿名内部类定义过多
- 可以让你的代码看起来很简洁
- 去掉了一堆没有意义的代码，只留下核心的逻辑



### 函数式接口

- 任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口

![image-20200617135326545](面试-多线程并发.assets/image-20200617135326545.png)



### lambda 演化过程

1. 接口 + 实现类

    ```java
    interface ILike {
        public abstract void lambda() ;
    }
    
    class Like implements ILike {
    
        public void lambda() {
            System.out.println("I like lambda 1.");
        }
    }
    ```

2. 内部类

    ```java
    public class TestLambda {
    
        static class Like2 implements ILike {
    
            public void lambda() {
                System.out.println("I like lambda 2.");
            }
        }
    
    
        public static void main(String[] args) {
            Like like1 = new Like();
            like1.lambda();
    
            new Like2().lambda();
    
        }
    }
    ```

3. 方法内部类

    ```java
    public static void main(String[] args) {
        Like like1 = new Like();
        like1.lambda();
    
        new Like2().lambda();
    	
        // 方法内部类
        class Like3 implements ILike {
    
            public void lambda() {
                System.out.println("I like lambda 3.");
            }
        }
        
        new Like3().lambda();
    
    
    
    }
    ```

4. 匿名类

    ```java
    new ILike() {
    
        public void lambda() {
            System.out.println("I like lambda 4.");
        }
    }.lambda();
    ```

5. lambda表达式

    ```java
    like = ()->{
            System.out.println("I like lambda 5.");
    };
    
    like.lambda();
    ```

6. 带参数的lambda表示式

    ```java
    interface ILove {
        void love(int a) ;
    }
    
    ILove love = null;
    love = (int a)->{
    System.out.println("i like this one -->" +  a);
    };
    ```

    



# ThreadLocal

> 具有线程的隔离性，一个ThreadLocal中set的变量只能本线程去get，其他线程是无法获得的。

## 概念

**关键词：** 1、数据传输  2、多线程

**在项目开发过程之中，ThreadLocal是一个最为重要的引用数据类型的传递操作类，利用这个类可以非常轻松的实现数据的传输，同时也可以保证多个线程下的数据传输的正确性。**



![image-20200727230142615](面试-多线程并发.assets/image-20200727230142615.png)



```java
package com.kicc.threadlocal;

/**
 * @author Kicc
 * @date 20/7/27 下午 9:55
 */
public class Test1 {


    public static void main(String[] args) {
        String [] values = new String[]{
                "String1",
                "String2",
                "String3"
        } ;

        for (String value:values) {
            new Thread(() -> {

                Resource.message = new Message();
                Resource.message.setContent(value);
                MessagePrint.print();

            }).start();
        }
    }

}

class Resource {
    public static Message message;
}

class MessagePrint {
    public static void print() {
        System.out.println("【MessagePrint】" + Resource.message.getContent());
    }
}

class Message {
    private String content ;

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }
}
```

**预期的输出结果**

```
【MessagePrint】String1
【MessagePrint】String2
【MessagePrint】String3
```



**输出结果**

```
【MessagePrint】String1
【MessagePrint】String1
【MessagePrint】String1
或者
【MessagePrint】String2
【MessagePrint】String2
【MessagePrint】String2
或者
【MessagePrint】String3
【MessagePrint】String3
【MessagePrint】String3
```



通过多线程的执行分析就可以发现当前程序设计的问题； 现在原本设计有三个线程对象，希望的处理形式是可以每一个线程都执行各自的信息输出，但是最终执行的结果却安全不正确了。那么是什么原因呢？

![](面试-多线程并发.assets/image-20200727220423491.png)

![image-20200727220812430](面试-多线程并发.assets/image-20200727220812430.png)



> 引入ThreadLocal

**重要的三个方法**：

| No.  | 方法名称                 | 类型 |                                      |
| ---- | ------------------------ | ---- | ------------------------------------ |
| 01   | public void set(T value) | 普通 | 保存数据，每一个线程只能保存一个数据 |
| 02   | public T get()           | 普通 | 获取当前线程保存的数据               |
| 03   | public void remove()     | 普通 | 清楚线程的数据                       |



```java
package com.kicc.threadlocal;

/**
 * @author Kicc
 * @date 20/7/27 下午 9:55
 */
public class Test1 {


    public static void main(String[] args) {
        String [] values = new String[]{
                "String1",
                "String2",
                "String3"
        } ;

        for (String value:values) {
            new Thread(() -> {
                // set：哪一个线程独占对象
                Resource.MESSAGE_THREAD_LOCAL.set(new Message());
                // 设置值
                Resource.MESSAGE_THREAD_LOCAL.get().setContent(value);
                MessagePrint.print();

            }).start();
        }
    }
}


class Resource {
    // 定义ThreadLocal 存储线程独占的 Message
    public static final ThreadLocal<Message> MESSAGE_THREAD_LOCAL = new ThreadLocal<Message>();
}

class MessagePrint {
    /**
     * 获取当前线程所保存的Message对象，并打印输出
     */
    public static void print() {
        System.out.println("【MessagePrint】" + Resource.MESSAGE_THREAD_LOCAL.get().getContent());
    }
}

class Message {
    private String content ;

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }
}
```

**程序输出**

```
【MessagePrint】String1
【MessagePrint】String2
【MessagePrint】String3
```



**本程序直接利用了ThreadLocal实现多个线程对象不同的数据存储，由于所有的存储都是以当前对象的形式作为了Key，那么只要当前对象有数据就可以直接获取数据并且实现引用对象的传输。在实际的项目开发过程里，一般使用ThreadLocal的代码都属于核心的资源对象传输。**



### 原理

**有这么一段代码**

```java
package com.kicc.threadlocal;

import java.sql.Time;
import java.util.concurrent.TimeUnit;

/**
 * @author Kicc
 * @date 20/7/28 下午 1:05
 */
public class Test2 {


    static ThreadLocal<Person> tl = new ThreadLocal<>();

    public static void main(String[] args) {


        new Thread(()-> {
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            tl.set(new Person());
        }).start();


        new Thread(()->{
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            Person person = tl.get();
            System.out.println(person);
        }).start();

    }


}


class Person {
    private String name = "sss" ;
}
```

**输出结果**

null



> set 方法

![image-20200728130025620](面试-多线程并发.assets/image-20200728130025620.png)

1. set 是 传入一个对象

2. 获取当前线程

3. 把当前线程传入getMap，获取一个ThreadLocalMap

    1. ![image-20200728130132936](面试-多线程并发.assets/image-20200728130132936.png)
    2. 这个`t.threadLocals`是Thread类持有的字段
    3. ![image-20200728131326869](面试-多线程并发.assets/image-20200728131326869.png)

4. map.set(this. value)： this指的是当前的ThreadLocal；而这个map是每个线程独占的

    1. ```java
        private void set(ThreadLocal<?> key, Object value) {
        
            // We don't use a fast path as with get() because it is at
            // least as common to use set() to create new entries as
            // it is to replace existing ones, in which case, a fast
            // path would fail more often than not.
        
            // 创建一个Entry对象 = 【Key - value】
            Entry[] tab = table;
            int len = tab.length;
            int i = key.threadLocalHashCode & (len-1);
        
            for (Entry e = tab[i];
                 e != null;
                 e = tab[i = nextIndex(i, len)]) {
                ThreadLocal<?> k = e.get();
        
                if (k == key) {
                    e.value = value;
                    return;
                }
        
                if (k == null) {
                    replaceStaleEntry(key, value, i);
                    return;
                }
            }
        
            // 把key-value装入 tab中， key = ThreadLocal， value = person
            tab[i] = new Entry(key, value);
            int sz = ++size;
            if (!cleanSomeSlots(i, sz) && sz >= threshold)
                rehash();
        }
        ```

    2. ```java
        // Entry 是一个静态内部类，是弱引用的子类
        static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;
        
            Entry(ThreadLocal<?> k, Object v) {
                // 构造方法调用了父类构造
                // 也就是创建了一个 WeakReference 指向了k， k=threadLocal
                super(k);
                value = v;
            }
        }
        ```

    3. **为什么要使用弱引用？**

        1. 若是强引用，即使手动设置 `tl=null`，但key的引用依然指向ThreadLocal对象，所以会有内存的泄露。
        2. 若是弱引用，当我们设置 `tl=null`，此时只有 map中的key有一个弱引用指向 ThreadLocal对象，GC一次就能回收
        3. **但是**，如果手动设置 `tl=null`， key作为一个弱引用，很容易被回收；不过 key对应的value (person) 这块内存就永远不可能被访问到了！也会造成内存的泄露
        4. 因此为了避免这些问题，当一个ThreadLocal中的数据不再使用的时候，要 手动执行 remove 方法移除。



> 整体流程图

![image-20200728134107598](面试-多线程并发.assets/image-20200728134107598.png)



**每个线程有自己独占的Map：threadlocals，因此是完全的线程隔离的。**









## 面试问题



### 1、ThreadLocal用在什么地方？

> 如果在单线程的环境下，是不需要使用ThreadLocal的。

Spring中的事务用到了ThreadLocal，目的是让同一个线程始终操作同一个连接。而不是使用不同的连接去操作数据库。



> ThreadLocal的用途

- **保存线程上下文信息，在任意需要的地方可以获取！！！**

- **线程安全的，避免某些情况需要考虑线程安全必须同步带来的性能损失！！！**



> 保存线程上下文信息，在任意需要的地方可以获取



> 线程安全的，避免某些情况需要考虑线程安全必须同步带来的性能损失

![img](面试-多线程并发.assets/16b6e0469ecfe7b0)

每个线程往ThreadLocal中读写数据是线程隔离，互相之间不会影响的，所以**ThreadLocal无法解决共享对象的更新问题！**



![img](面试-多线程并发.assets/16b6e0469cc06cba)



![img](面试-多线程并发.assets/1738b45487065b90)

### 2、ThreadLocal中使用的Map为什么是数组，而不是链表？

![image-20200802113022847](面试-多线程并发.assets/image-20200802113022847.png)

在ThreadLocal.set方法中，使用的是Entry数组保存的 Key-Value 对，Entry是弱引用的子类。

一个线程中可以有多个ThreadLocal来存放不同类型的对象，所有的对象都可以放在当前线程的ThreadLocalMap里，就用数组来存放。



### 3、没有用链表如何解决Hash冲突

可以看待用了一个  `threadLocalHashCode`来解决冲突， 存储的时候会根据ThreadLocal对象的hash值，定位到Table的 index。

- 如果index上是空的，就初始化一个Entry放在这个位置上
- 如果index不是空的，而且key相等，刷新覆盖即可
- 如果index不是空的，但是key不相等，那就找下一个空的位置，放进去

![image-20200802114438807](面试-多线程并发.assets/image-20200802114438807.png)

同样，在get的时候，根据ThreadLocal对象的hash值，定位到Table中

- 如果和当前位置的key一致，则返回
- 如果不一致，继续找



### 4、说说对象都存放在哪里？

在Java中，栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存，而堆内存中的对象对所有线程可见，堆内存中的对象可以被所有线程访问。



#### 5、那么是不是说ThreadLocal的实例以及其值存放在栈上呢？

不是的。ThreadLocal是一个实例对象。Java中的实例对象都是存放在堆内存中的。

因为ThreadLocal实例实际上也是被其创建的类持有（更顶端应该是被线程持有），而ThreadLocal的值其实也是被线程实例持有，它们都是位于堆上，只是通过一些技巧将可见性修改成了线程可见。



#### 6、有办法共享 不同线程的ThreadLocal数据吗？

有一个办法。

![image-20200802114854481](面试-多线程并发.assets/image-20200802114854481.png)

每一个Thread实例在初始化的时候，会传入 `inheritThreadLocals=true` 表示存在。

我们可以在父线程（主线程）中创建一个  `InheritableThreadLocal` 实例，然后在子线程中得到这个 `InheritableThreadLocal` 实例设置的值。



![image-20200802115140146](面试-多线程并发.assets/image-20200802115140146.png)

只要存在父线程，那么子线程初始化的时候就会把父线程的 `inheritableThreadLocals` 传递给子线程。



# 基础三大类



## Java Thread

不推荐使用的方式。自JDK1.0.性能上不高。



> 线程的状态

```java
public static enum State {
   /**
    * A Thread which has not yet started.
    */
   NEW,
   /**
    * A Thread which is running or suspended.
    */
   RUNNABLE,
   /**
    * A Thread which is blocked on a monitor.
    */
   BLOCKED, 
   /**
    * A Thread which is waiting with no timeout.
    * 可以一直等
    */
   WAITING,
   /**
    * A Thread which is waiting with a timeout.
    * 超时等待，时间过了就不等了
    */
   TIMED_WAITING, 
   /**
    * A thread which is no longer alive.
    */
   TERMINATED }
```



>sleep 和 wait 区别

**1、来自不同的类**

- wait：Object
- sleep：Thread

开发中不会使用 Thread.sleep， 而是JUC下的 `TimeUnit`

![image-20200727162629892](面试-多线程并发.assets/image-20200727162629892.png)

**2、关于锁的释放**

- sleep：不会释放锁
- wait：放弃当线程的锁



**3、使用的范围不同**

- sleep：可以在任意程序处使用
- wait：在同步代码中使用



**4、是否需要捕获异常**

- sleep：需要捕获异常
- wait：不必要





> Demo

```java
class MyThread1 extends Thread {
    private String name;
    public MyThread1(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(name + "运行：" + i);
            try {
                sleep( (int) Math.random()*10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread1 t1 = new MyThread1("线程1");
        MyThread1 t2 = new MyThread1("线程2");
        t1.start();
        t2.start();

    }
}
```

多次重复执行得到的结果会不同。



注意：start()方法调用后 **并不是** 立即执行了多线程代码。而是将该线程变成了可运行态（Runnable）。

什么时候执行时OS说了算。







## Java Runnable 

推荐使用的方式 JDK1.0





## J.U.C Callable

![image-20200727144804255](面试-多线程并发.assets/image-20200727144804255.png)

一个问题：无法返回。

```java
package com.kicc.runnable;

/**
 * @author Kicc
 * @date 20/7/27 下午 2:52
 */


public class MyThread implements Runnable {

    private String result = "【返回结果】";
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            result += "Gooo.!";
        }
    }


    public String getResult() {
        return this.result;
    }
}
```



```java
package com.kicc.test;

import com.kicc.runnable.MyThread;

/**
 * @author Kicc
 * @date 20/7/27 下午 2:54
 */
public class RunnableTest {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        Thread t1 = new Thread(myThread);
        t1.start();
        try {
            t1.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(myThread.getResult());
    }
}
// 输出
【返回结果】
```

如果不加 `join`，无法在线程执行之前得到 `result`



```java
@FunctionalInterface
public interface Callable<V> {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
```

当前给出的call()方法的功能就类似于Runnable接口里面的run()方法的功能，因为这个方法是线程的主体方法。这个主体方法的一个最大的特征就是可以有一个数据的返回结果，并且返回结果的类型可以通过外部的泛型来进行动态声明。

​	因为Callable接口牵扯到其最终的结果返回，所以它的使用会比较繁琐，Callable采用了**异步**的处理架构，所以虽然其是一个线程类，由Thread启动，但是对于异步数据的返回就必须使用一个最为重要的接口：Future。

> Thread类的构造方法

![image-20200727150524392](面试-多线程并发.assets/image-20200727150524392.png)



Thread类中没有一个构造方法是接受Callable对象的



> Future接口

![image-20200727150718518](面试-多线程并发.assets/image-20200727150718518.png)

异步数据返回的  `get()` 方法就是接受Callable接口里面的`call()`方法返回的数据信息



**但是**Thread 和 Future Callable没有什么联系， 所以需要一个中间的联系人：

![image-20200727151011073](面试-多线程并发.assets/image-20200727151011073.png)



但是到这里，Thread和Callable之间还是不存在什么联系。而我们看到在``RunnableFuture接口``下，有一个实现类`FutureTask`

这个类下有两个构造方法：

![image-20200727151514266](面试-多线程并发.assets/image-20200727151514266.png)

> 联系Callable接口

![image-20200727151527477](面试-多线程并发.assets/image-20200727151527477.png)

> 补救方法

![image-20200727151534172](面试-多线程并发.assets/image-20200727151534172.png)

> 所有的联系

![image-20200727151329382](面试-多线程并发.assets/image-20200727151329382.png)

- FutureTask 实现了 RunnableFuture 接口
- RunnableFuture 接口 继承了 Future 和 Runnable 两个接口
- FutureTask的构造方法中可以传入 Runnable 或者 Callable
- 所以FutureTask 接收 Callable， 自己是一个Runnable
- Thread 接收 FutureTask 是因为 Thread 可以接收 Runnable
- Thread 启动线程后，通过FutureTask.get 获得 异步的返回结果





> 实战，使用Callable实现多线程



```java
public class CallableThread implements Callable<String> {
    @Override
    public String call() throws Exception {
        String result = "" ;
        for (int i = 0; i < 10; i++) {
            result+="Gooooooo.!" + i;
        }
        // 异步返回
        return result;
    }


}
```





```java
@Test
public void testCallable() throws ExecutionException, InterruptedException {
    CallableThread mythread = new CallableThread();

    FutureTask<String> task = new FutureTask<String>(mythread);


    Thread thread = new Thread(task);

    thread.start();

    // 通过future.get
    System.out.println(task.get());
}
```





## 区分使用使用场景

**区分的点：**

如果不需要返回值就使用Runnable，如果需要线程执行完毕后有一个返回值就使用Callable.



如果一个类继承Thread，则不适合资源共享。但是如果实现了Runnable接口的话，则很容易的实现资源共享。



> Runnable 和 Thread 两种方式的区别

**总结：**

实现Runnable接口比继承Thread类所具有的优势：

1）：适合多个相同的程序代码的线程去处理同一个资源

2）：可以避免java中的单继承的限制

3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立

4）：线程池只能放入实现Runnable或callable类线程，不能直接放入继承Thread的类





因为main方法也启动了一个线程，在java中所有的线程都是同时启动的，至于什么时候可以运行，哪个优先执行是取决于cpu的调度。



在Java程序中，至少启动了两个线程。 main和Gc。

每当Java执行一个（主）类的时候，实际上都会启动一个JVM。对应到操作系统中就是JVM开启了一个**进程**。





# 进阶 JUC



**回顾之前的加锁方式：**

```java
package com.kicc.juc;

import java.util.Date;

/**
 * @author Kicc
 * @date 20/7/27 下午 5:09
 */
public class SaleTicketDemo1 {


    public static void main(String[] args) {

        Ticket ticket = new Ticket();

        Date date = new Date();
        long start = date.getTime();

        new Thread(()->{
            for (int i = 0; i < 50; i++) {
                ticket.sale();
            }
        }, "线程A").start();


        new Thread(()->{
            for (int i = 0; i < 50; i++) {
                ticket.sale();
            }
        }, "线程B").start();


        new Thread(()->{
            for (int i = 0; i < 50; i++) {
                ticket.sale();
            }
        }, "线程C").start();


    }
}


class Ticket {

    private int num = 50 ;

    public synchronized void sale() {
        if (num>0) {
            System.out.println(Thread.currentThread().getName() +
                    "卖出了第" + (num--) + "票， 剩余：" + num );
        }
    }
}
```

要使程序按照顺序输出，则必须使用 `synchronized` 关键字





## Lock 锁

![image-20200727180447289](面试-多线程并发.assets/image-20200727180447289.png)

Lock接口是JUC中的锁接口，它有这么几个实现类。



> 使用方式（来自源码）

![image-20200727181037363](面试-多线程并发.assets/image-20200727181037363.png)

```java
Lock l = ;
l.lock();
try(){
    
} finally {
    l.unlock();
}
```





###  ReentranLock， 可重入锁

>  ReentranLock， 可重入锁

![image-20200727180657194](面试-多线程并发.assets/image-20200727180657194.png)

- 公平锁：不允许插队，按照顺序来。 
    - A线程需要执行 3小时， B线程需要3秒，B需要等3h才执行3s
- **非公平锁：不公平，可以插队。** （默认使用）



```java
package com.kicc.juc;

import java.util.Date;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author Kicc
 * @date 20/7/27 下午 5:09
 */
public class SaleTicketDemo1 {


    public static void main(String[] args) {

        Ticket2 ticket = new Ticket2();

        Date date = new Date();
        long start = date.getTime();

        new Thread(()->{for (int i = 0; i < 50; i++) { ticket.sale();}}, "线程A").start();


        new Thread(()->{for (int i = 0; i < 50; i++) {ticket.sale(); }}, "线程B").start();

        new Thread(()->{for (int i = 0; i < 50; i++) {ticket.sale(); }}, "线程C").start();



    }
}


class Ticket {

    private int num = 50 ;

    public synchronized void sale() {
        if (num>0) {
            System.out.println(Thread.currentThread().getName() +
                    "卖出了第" + (num--) + "票， 剩余：" + num );
        }
    }
}

class Ticket2 {

    private int num = 50 ;

    // 定义一个可重入锁
    Lock lock = new ReentrantLock();

    public void sale() {

        lock.lock();

        try {
            // try 中放置业务逻辑
            if (num>0) {
                System.out.println(Thread.currentThread().getName() +
                        "卖出了第" + (num--) + "票， 剩余：" + num );
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // finally中释放锁
            lock.unlock();
        }

    }
}
```



> Lock锁、synchronzied 之间的区别

1. synchronized 是Java关键字，Lock是接口，有几个实现类
2. synchronized 无法判断锁的状态，Lock可以判断是否获取了锁
3. synchronized 会自动释放，lock需要手动释放锁！如果不释放，会死锁
4. synchronized 
    - 线程A获得锁后，线程B只能等待
    - 线程A若不幸进入了阻塞，线程B还是只能等待 （此时CPU就没有工作了！！！==我们搞这么多高并发的东西，根本的目的就是尽可能的利用CPU的全部性能==）
5. synchronized 是可重入锁，不可以中断，非公平；Lock 是可重入锁，可以判断锁，非公平（但是可以手动设置为公平）
6. synchronized 适合锁少量的同步代码；Lock 适合大量同步代码；





### synchronized 原理



早在JDK1.0-1.2时， synchronized 关键字是一把重量级的锁。JVM的线程与OS中的线程是1：1的对应关系。多线程下的每一次线程切换都需要经过OS的调度，效率不高。

![image-20200729104252952](面试-多线程并发.assets/image-20200729104252952.png)

在Golang语言中，有协程的概念。用户态的线程和内核态的线程是M：N的关系。一个OS中的线程管理着许多的协程。协程也被称为轻量级线程。协程在用户态中的切换效率高。不再需要过多依赖OS的帮助。



到了JDK1.6以上，这种重量级的线程调度方式发生了变化。**出了JVM内部的锁升级过程！**

### ![image-20200729104939455](面试-多线程并发.assets/image-20200729104939455.png)

**JDK1.6后的版本在使用关键字 synchronized 的时候不是直接用互斥量进行加锁（这是一种重量级锁）。而是一开始没有锁，慢慢的会出现锁的升级。**



> 锁升级的过程

- 当第一个线程来的时候，并没有发生锁的竞争。将资源的markword信息修改，改成当前线程的ID号。这里也就是偏向锁
- 当有第二个线程来竞争，需要把偏向锁**撤销**，多个线程开始自旋锁的竞争。这是一个用户态的竞争，不涉及OS。
    - 补充：如果是OS级别的锁竞争。OS会维护一下队列，没有竞争到锁的线程都会进入等待队列中。
    - 忙竞争自旋锁时，对应的就是 CAS。 一个线程在自己的栈中进行操作，当写入主内存的时候进行一个比较操作，如果这个变量已经被修改过了，那么就重新操作一遍。
- 但是自旋的过程是在消耗CPU的



### CAS

![image-20200728153438205](面试-多线程并发.assets/image-20200728153438205.png)



> 如何处理ABA问题

除了判断需要修改的值是否不同之外，可以加一个版本号。没经过一次修改，版本号必须要改动，这样就可以判断是否修改过。



> 来有一个面试的问题：
>
> 重量级锁的效率是否一定比自旋锁低？

**不是的，要分场景：**

- 当有一个线程A占用了锁，同时它的执行很快就会结束的情况下，其他的线程使用自旋锁方式可以较快地进行修改操作
- 当一个线程B占用了锁，但是它的执行时间非常长，**其他的线程要执行的时间又很短**，它们使用自选锁方式不停的自旋转等待，一直等不到执行。这种情况下，自旋锁还不如重量级锁。
- 自旋等待是需要消耗cpu资源的，如果一直执行不到，那么再怎么自旋也没用。不如用个重量级锁，竞争到cpu资源后，立刻执行一下。



> 问题2 ：
>
> CAS compare And swap 这个操作是原子操作吗？

**面试官，不是的。**

当线程A执行完compare 发现 当前变量被没有被修改过时，线程B可以抢先在线程A写入之前 修改变量的值。 那么也就是说线程B的修改操作被线程A覆盖！

但是 

![image-20200728223627547](面试-多线程并发.assets/image-20200728223627547.png)

![image-20200728223638181](面试-多线程并发.assets/image-20200728223638181.png)

![image-20200728223652042](面试-多线程并发.assets/image-20200728223652042.png)

`AtomicInteger.incrementAndGet()` 方法最底层是调用了native 方法，这是一个cpp的实现方法。

```c++
UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))
  UnsafeWrapper("Unsafe_CompareAndSwapInt");
  oop p = JNIHandles::resolve(obj);
  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);
  // 这一行
  return (jint)(Atomic::cmpxchg(x, addr, e)) == e;
UNSAFE_END
```



```c++
// Atomic::cmpxchg 方法
inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) {
  int mp = os::is_MP();
    // 最终执行了一个汇编语句：LOCK_IF_MP 表示如果是多核心的CPU，则会加一个锁
    // 也就是说在执行 compare And Swap的时候 Java层面不是一个原子性的操作
    // 但是会在汇编层面上在线程和cpu之间的总线加一个锁
  __asm__ volatile (LOCK_IF_MP(%4) "cmpxchgl %1,(%3)"
                    : "=a" (exchange_value)
                    : "r" (exchange_value), "a" (compare_value), "r" (dest), "r" (mp)
                    : "cc", "memory");
  return exchange_value;
}
```

因此，反推回来`AtomicInteger.incrementAndGet()` 就是一个原子性操作了。



```java
package com.kicc.threadlocal;

import java.util.Arrays;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * @author Kicc
 * @date 20/7/28 下午 10:11
 */
public class CAS {


    private static AtomicInteger m = new AtomicInteger(0);
//    private static int m=0;

    public static void main(String[] args) throws InterruptedException {

        Thread[] threads = new Thread[100];

//        CountDownLatch latch = new CountDownLatch(threads.length);
        Object o = new Object();

        for (int i = 0; i < threads.length; i++) {
            new Thread(()->{
                    for (int j = 0; j < 1000; j++) {
                        m.incrementAndGet();
                    }
                    // 将count值减1
//                    latch.countDown();
            }).start();
        }

        // count == 0 后，才继续执行后续代码
//        latch.await();

        //TimeUnit.SECONDS.sleep(3);
        System.out.println(m);
    }

}
```

**输出是多少？**

小于等于100000



**为什么？** 不是说 `AtomicInteger.incrementAndGet()` 是一个原子性的操作吗？

其实 m 的值是 100000，但是主线程可能在另外100个线程执行完之前就 输出了。而 自增的操作依然在进行，所以输出就可能小于100000.

我添加一个 `CountDownLatch latch = new CountDownLatch(threads.length);`保证让所有的线程执行完毕。

```java
package com.kicc.threadlocal;

import java.util.Arrays;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * @author Kicc
 * @date 20/7/28 下午 10:11
 */
public class CAS {


    private static AtomicInteger m = new AtomicInteger(0);
//    private static int m=0;

    public static void main(String[] args) throws InterruptedException {

        Thread[] threads = new Thread[100];

        CountDownLatch latch = new CountDownLatch(threads.length);
        Object o = new Object();

        for (int i = 0; i < threads.length; i++) {
            new Thread(()->{
                    for (int j = 0; j < 1000; j++) {
                        m.incrementAndGet();
                    }
                    // 将count值减1
                    latch.countDown();
            }).start();
        }

        // count == 0 后，才继续执行后续代码
        latch.await();

        // 如果不适用latch，让主线程睡几秒也能使输出稳定在100000
        //TimeUnit.SECONDS.sleep(3);
        System.out.println(m);
    }

}
```





### 生产者与消费者问题

#### 在不使用JUC下如何实现

> 通过wait 、 notifyAll 方法实现 生产者与消费者

```java
package com.kicc.produceservice;

/**
 * @author Kicc
 * @date 20/7/27 下午 7:18
 */
public class Demo {
    public static void main(String[] args) {
        Service service = new Service();

        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    service.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "A线程").start();


        new Thread(()->{
            for (int i = 0; i < 10; i++) {
                try {
                    service.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "B线程").start();
    }

}

// 解耦
// 业务类
class Service {
    private int num = 0;


    // 
    public synchronized void increment() throws InterruptedException {
        if (num!=0) {
            this.wait();
        }
        System.out.println(Thread.currentThread().getName() + ", num:" + num);
        num++;
        // 我加完了，通知其他的线程可以执行了
        this.notifyAll();
    }

    public synchronized void decrement() throws InterruptedException {
        if (num==0) {
            this.wait();
        }
        System.out.println(Thread.currentThread().getName() + ", num:" + num);
        num--;
        // 我减完了，通知其他的线程可以执行了
        this.notifyAll();
    }


}
```



> 虚假唤醒问题

**有线程被异常唤醒**

```java
public class Demo {
    public static void main(String[] args) {
        Service service = new Service();
        int times = 11;

        new Thread(()->{
            for (int i = 0; i < times; i++) {
                try {
                    service.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "A线程").start();


        new Thread(()->{
            for (int i = 0; i < times; i++) {
                try {
                    service.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "B线程").start();

        new Thread(()->{
            for (int i = 0; i < times; i++) {
                try {
                    service.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "C线程").start();

        new Thread(()->{
            for (int i = 0; i < times; i++) {
                try {
                    service.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "D线程").start();
    }

}
```

现在有四个线程去执行 `increment` 和 `decrement` 方法。

预期的话，应该是

```
A线程, num:0
B线程, num:1
A线程, num:0
B线程, num:1
A线程, num:0
B线程, num:1
A线程, num:0
B线程, num:1
A线程, num:0
B线程, num:1
C线程, num:0
D线程, num:1
C线程, num:0
D线程, num:1
C线程, num:0
D线程, num:1
C线程, num:0
D线程, num:1
C线程, num:0
D线程, num:1
```



**而实际**

```java
A线程, num:0
B线程, num:1
A线程, num:0
B线程, num:1
A线程, num:0
B线程, num:1
A线程, num:0
B线程, num:1
C线程, num:0
A线程, num:1
B线程, num:2
A线程, num:1
B线程, num:2
B线程, num:1
C线程, num:0
A线程, num:1
D线程, num:2
D线程, num:1
C线程, num:0
B线程, num:1
A线程, num:0
B线程, num:1
C线程, num:0
D线程, num:1
C线程, num:0
D线程, num:1
C线程, num:0
D线程, num:1
A线程, num:0
B线程, num:1
C线程, num:0
D线程, num:1
A线程, num:0
B线程, num:1
D线程, num:0
D线程, num:-1
D线程, num:-2
C线程, num:-3
D线程, num:-2
D线程, num:-3
A线程, num:-4
C线程, num:-3
... 程序没有执行完毕
    
    
```

> 上面问题的核心是: A被唤醒后,仍然需要先获取锁再**继续执行逻辑**,而唤醒-获取锁并不是原子性的,唤醒之后锁可能被其他线程获取,这时A再次获取到锁时,产品已经没了,由于是**继续执行**,就没有再检查产品数量,导致异常情况的出现

也就是说一个线程被唤醒了，但是并没有及时的获得锁，但是已经把变量获取到了。



> 解决办法

把 `if` 换成 `while`



#### JUC版本的实现

```java
// 官方注释
* class BoundedBuffer {
*   <b>final Lock lock = new ReentrantLock();</b>
*   final Condition notFull  = <b>lock.newCondition(); </b>
*   final Condition notEmpty = <b>lock.newCondition(); </b>
*
*   final Object[] items = new Object[100];
*   int putptr, takeptr, count;
*
*   public void put(Object x) throws InterruptedException {
*     <b>lock.lock();
*     try {</b>
*       while (count == items.length)
*         <b>notFull.await();</b>
*       items[putptr] = x;
*       if (++putptr == items.length) putptr = 0;
*       ++count;
*       <b>notEmpty.signal();</b>
*     <b>} finally {
*       lock.unlock();
*     }</b>
*   }
*
*   public Object take() throws InterruptedException {
*     <b>lock.lock();
*     try {</b>
*       while (count == 0)
*         <b>notEmpty.await();</b>
*       Object x = items[takeptr];
*       if (++takeptr == items.length) takeptr = 0;
*       --count;
*       <b>notFull.signal();</b>
*       return x;
*     <b>} finally {
*       lock.unlock();
*     }</b>
*   }
* }
* </pre>
```

可以很明显的看到 这里涉及到一个新的接口  `Condition` 用来代替之前的监视器

- Object.wait() ==> Condition.await();
- Object.notifyAll() ==> Condition.signalAll()



```java
package com.kicc.juc;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author Kicc
 * @date 20/7/27 下午 7:45
 */
public class ProduceConsumeDemo {
    public static void main(String[] args) {
        Service service = new Service();
        int times = 3;

        new Thread(()->{
            for (int i = 0; i < times; i++) {
                try {
                    service.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "A线程").start();


        new Thread(()->{
            for (int i = 0; i < times; i++) {
                try {
                    service.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "B线程").start();

        new Thread(()->{
            for (int i = 0; i < times; i++) {
                try {
                    service.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "C线程").start();

        new Thread(()->{
            for (int i = 0; i < times; i++) {
                try {
                    service.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "D线程").start();
    }

}


class Service {
    private int num = 0;

    // 可重入锁
    Lock lock = new ReentrantLock();
    // 监视器
    Condition condition = lock.newCondition();



    public void increment() throws InterruptedException {

        lock.lock();

        try {
            // 业务逻辑
            while (num!=0) {
                condition.await();
            }
            System.out.println(Thread.currentThread().getName() + ", num:" + num);
            num++;
            // 唤醒
            condition.signalAll();

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void decrement() throws InterruptedException {

        // 先加锁
        lock.lock();

        try {
            while (num==0) {
                condition.await();
            }
            System.out.println(Thread.currentThread().getName() + ", num:" + num);
            num--;
            condition.signalAll();

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 释放锁
            lock.unlock();
        }

    }

}
```

> 那么Condition的优势是什么呢？

**精准地通知唤醒**



> 场景设定

有三个线程A、B、C，A线程执行完去唤醒B、B线程执行完去唤醒C、C线程执行完去唤醒A。

```java
package com.kicc.juc;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author Kicc
 * @date 20/7/27 下午 8:14
 */
public class SpecificSignal {


    public static void main(String[] args) {

        int times = 5;
        Data data = new Data();

        new Thread(()->{
            for (int i = 0; i < 5; i++) {
                data.printA();
            }
        }, "线程A").start();

        new Thread(()->{
            for (int i = 0; i < 5; i++) {
                data.printB();
            }
        }, "线程B").start();

        new Thread(()->{
            for (int i = 0; i < 5; i++) {
                data.printC();
            }
        }, "线程C").start();
    }



}


class Data {

    /**
     * number == 1, 执行A
     * number == 2, 执行B
     * number == 3, 执行C
     */
    private int number = 1;
    private Lock lock = new ReentrantLock();

    private Condition conditionA = lock.newCondition();
    private Condition conditionB = lock.newCondition();
    private Condition conditionC = lock.newCondition();

    public void printA() {
        lock.lock();

        try {
            while (number!=1) {
                // 监视器A是线程A的监视器
                conditionA.await();
            }
            System.out.println(Thread.currentThread().getName() + "AAAA");
            number = 2;
            // 去唤醒B
            conditionB.signal();

        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void printB() {
        lock.lock();

        try {
            while (number!=2) {
                // 监视器B是线程B的监视器
                conditionB.await();
            }
            System.out.println(Thread.currentThread().getName() + "BBBBB");
            number = 3;
            // 去唤醒C
            conditionC.signal();

        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void printC() {
        lock.lock();

        try {
            while (number!=3) {
                // 监视器C是线程C的监视器
                conditionC.await();
            }
            System.out.println(Thread.currentThread().getName() + "CCCCC");
            number = 1;
            // 去唤醒A
            conditionA.signal();

        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

}
```

**有了精确的线程唤醒，那么可以做到流程的稳定。**

**在多线程并发的情况下，也必须按照既定的顺序进行执行**





### 8锁现象

####  1 & 2

> 如何判断锁的是谁 永远知道什么是锁，锁到底锁的是谁。



```java
package com.kicc.lock8;

/**
 * @author Kicc
 * @date 20/7/27 下午 8:36
 * 8 锁，关于锁的 8 个问题
 * 1、标准情况下，两个线程先打印 发短信还是打电话？ 两个都是同步方法，共用一个对象
 * 2、send方法延迟 5秒， 两个线程先打印 发短信 还是 打电话？
 */
public class Test1 {

    public static void main(String[] args) {
        Phone phone = new Phone();

        // 有锁的存在
        new Thread(()->{
            // 先创建，先得到锁
            phone.send();
        }, "A").start();


        new Thread(()->{
            phone.call();
        }, "B").start();
    }
}


class Phone {

    // synchronized 方法 锁住的对象是方法 的调用者。
    // 两个方法都是锁住了方法的调用者，显然两个方法的调用者是同一个对象
    // 谁先得到了锁，谁就可以先执行
    public synchronized void send() {
        System.out.println("发短信");
    }

    public synchronized void call() {
        System.out.println("打电话");
    }

}
```

**请问以上代码的输出是？**

发短信

打电话



即便

```java
class Phone {

    public synchronized void send() throws InterruptedException {
		// 即便send方法中 sleep若干时间， 因为锁已经获得了，
        // 那么其他方法也只能等待send方法执行完毕
	    TimeUnit.SECONDS.sleep(5);
        System.out.println("发短信");
    }

    public synchronized void call() {
        System.out.println("打电话");
    }

}
```





####  3 & 4

> 同步方法与非同步方法

```java
package com.kicc.lock8;

import java.util.concurrent.TimeUnit;

/**
 * @author Kicc
 * @date 20/7/27 下午 8:43
 */
public class Test2 {

    public static void main(String[] args) {
        Phone2 phone = new Phone2();

        new Thread(()->{
            try {
                phone.send();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "A").start();



        new Thread(()->{
            phone.hello();
        }, "B").start();



    }
}


class Phone2 {

    public synchronized void send() throws InterruptedException {
        TimeUnit.SECONDS.sleep(5);
        System.out.println("发短信");
    }

    public synchronized void call() {
        System.out.println("打电话");
    }

    public void hello() {
        System.out.println("Hello");
    }
}
```

**请问以上代码的输出是？**

Hello  

 (等待5s) 发短信



因为hello方法不是一个同步方法，所以它不受到同步锁的约束。

```java
package com.kicc.lock8;

import java.util.concurrent.TimeUnit;

/**
 * @author Kicc
 * @date 20/7/27 下午 8:43
 * 3、增加了一个普通方法hello后，先执行发短信还是hello？
 * 4、两个对象，两个同步方法，各自调用 send 和 call， 哪个先执行？
 */
public class Test2 {

    public static void main(String[] args) {
        Phone2 phone1 = new Phone2();
        Phone2 phone2 = new Phone2();

        new Thread(()->{
            try {
                phone1.send();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "A").start();



        new Thread(()->{
            phone2.call();
        }, "B").start();



    }
}


class Phone2 {

    public synchronized void send() throws InterruptedException {
        TimeUnit.SECONDS.sleep(5);
        System.out.println("发短信");
    }

    public synchronized void call() {
        System.out.println("打电话");
    }

    public void hello() {
        System.out.println("Hello");
    }
}
```

**请问以上代码的输出是？**

打电话 

（等待5s）发短信



**如果send方法中没有加sleep，输出为：**

发短信

打电话



#### 5 & 6

```java
package com.kicc.lock8;

import java.util.concurrent.TimeUnit;

/**
 * @author Kicc
 * @date 20/7/27 下午 8:56
 */
public class Test3 {

    public static void main(String[] args) {
        Phone3 phone = new Phone3();

        new Thread(()->{
            try {
                phone.send();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "A").start();



        new Thread(()->{
            phone.call();
        }, "B").start();



    }
}


class Phone3 {

    // static 修饰后，锁的对象是 Class
    public static synchronized void send() throws InterruptedException {
        TimeUnit.SECONDS.sleep(5);
        System.out.println("发短信");
    }

    public static synchronized void call() {
        System.out.println("打电话");
    }

}
```

**请问以上代码的输出是？**

（等待5s）发短信 

打电话



**因为都是 static 方法， 都锁住了Class。所以还是 send方法先执行。**

**但是，如果 去掉 call方法的static，那么输出为：**

打电话 

（等待5s）发短信





#### 总结

**判断的关键点是 锁的对象是什么？  对象？  Class？** 

- static synchronized 锁的是Class
- synchronized 锁的 实例对象
- 普通方法没有锁，不受同步锁的影响



