# 并发



## 线程不安全



- 多个线程同时操作一个对象，产生线程不安全现象

假设这里是买火车票的情况

```java
public class ThreadTest1 implements Runnable {

    private int ticketNum = 10;

    @lombok.SneakyThrows
    public void run() {

        while (true) {
            if (ticketNum<=0) {
                break;
            }
            Thread.sleep(200);

            System.out.println(Thread.currentThread().getName() + "-->拿到了第"+ticketNum-- + "张票");

        }
    }

}
```



测试

```java
public class MyTest {

    public static void main(String[] args) {
        ThreadTest1 ticket = new ThreadTest1();

        // 多线程操作同一个对象，出现资源被重复使用的现象
        new Thread(ticket, "小明").start();
        new Thread(ticket, "老师").start();
        new Thread(ticket, "黄牛").start();
    }

}
```

```
小明-->拿到了第10张票
黄牛-->拿到了第9张票
老师-->拿到了第8张票
老师-->拿到了第7张票
小明-->拿到了第7张票
黄牛-->拿到了第6张票
老师-->拿到了第4张票
黄牛-->拿到了第3张票
小明-->拿到了第5张票
小明-->拿到了第2张票
黄牛-->拿到了第0张票
老师-->拿到了第1张票
```

可以看到，同一张票有多次被取到的情况。



# 线程状态



## 死亡

如何停止一个线程？

- 不推荐JDK提供的 stop(), destroy()方法。【已废弃】
- 推荐线程自己停下来。
- 建议使用一个标志位进行终止变量。当flag=false，则线程终止。



```java
public class TestStop implements Runnable {
    private boolean flag = true;

    public void run() {
        int i=0;
        while (flag) {
            System.out.println("run .... Thread" + i++);
        }
    }


    public void stop() {
        this.flag = false;
    }
}
```



## 创建





## 就绪

当线程调用start()方法时，线程就进入了就绪状态。





## 运行





## 阻塞



