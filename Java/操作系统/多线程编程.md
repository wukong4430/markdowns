# 1、 多线程概念

首先来了解一下操作系统中【线程】和【进程】的区别



- 进程：每个进程都有独立的【代码】和【数据空间】（数据上下文），进程间的切换会产生较大的开销。进程是资源分配的最小单位。
- 线程：同一类线程共享代码和数据空间。每个线程有独立的【运行栈】和程序计数器【PC】，线程切换的开销小。（线程是cpu调度的最小单位）

线程和进程一样分为**五个阶段**：创建、就绪、运行、阻塞、终止。



Java中实现多线程的方式：

1. 继承Thread
2. 实现Runnable接口



# 2、继承Thread方式

```java
class MyThread1 extends Thread {
    private String name;
    public MyThread1(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(name + "运行：" + i);
            try {
                sleep( (int) Math.random()*10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread1 t1 = new MyThread1("线程1");
        MyThread1 t2 = new MyThread1("线程2");
        t1.start();
        t2.start();

    }
}
```

多次重复执行得到的结果会不同。



注意：start()方法调用后 **并不是** 立即执行了多线程代码。而是将该线程变成了可运行态（Runnable）。

什么时候执行时OS说了算。



# 3、实现Runnable接口

```java

class MyThread2 implements Runnable{
	private String name;
 
	public MyThread2(String name) {
		this.name=name;
	}
 
	@Override
	public void run() {
		  for (int i = 0; i < 5; i++) {
	            System.out.println(name + "运行  :  " + i);
	            try {
	            	Thread.sleep((int) Math.random() * 10);
	            } catch (InterruptedException e) {
	                e.printStackTrace();
	            }
	        }
		
	}
	
}
```



使用方式：注意实现接口类的使用方式

```java
@Test
public void test2() {
    Thread t1 = new Thread(new MyThread2("线程3"));
    Thread t2 = new Thread(new MyThread2("线程4"));
    t1.start();
    t2.start();
}
}
```



# 3、继承和实现接口的区别

如果一个类继承Thread，则不适合资源共享。但是如果实现了Runnable接口的话，则很容易的实现资源共享。



**总结：**

实现Runnable接口比继承Thread类所具有的优势：

1）：适合多个相同的程序代码的线程去处理同一个资源

2）：可以避免java中的单继承的限制

3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立

4）：线程池只能放入实现Runnable或callable类线程，不能直接放入继承Thread的类





因为main方法也启动了一个线程，在java中所有的线程都是同时启动的，至于什么时候可以运行，哪个优先执行是取决于cpu的调度。



在Java程序中，至少启动了两个线程。 main和Gc。

每当Java执行一个（主）类的时候，实际上都会启动一个JVM。对应到操作系统中就是JVM开启了一个**进程**。





# 4、线程状态转换



![img](多线程编程.assets/20150309140927553)

1、新建状态（New）：新创建了一个线程对象。
2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)
（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）
5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。



> 其他四种的状态都比较好理解，阻塞状态需要多注意点。尤其是wait和同步 synchronized



# 5、线程调度

常用调度方法介绍



- ```
    Thread.sleep(long millis)  
    ```

    线程睡眠：使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。

- ```
    Object.wait() 
    ```

    线程等待：导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。

- ```
    Thread.yield()
    ```

    线程让步：**暂停**当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。

     **yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。**

    因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。

    ```java
    class ThreadYield extends Thread{
        public ThreadYield(String name) {
            super(name);
        }
     
        @Override
        public void run() {
            for (int i = 1; i <= 50; i++) {
                System.out.println("" + this.getName() + "-----" + i);
                // 当i为30时，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行）
                if (i ==30) {
                    this.yield();
                }
            }
    	
    }
    }
     
    public class Main {
     
    	public static void main(String[] args) {
    		
    		ThreadYield yt1 = new ThreadYield("张三");
        	ThreadYield yt2 = new ThreadYield("李四");
            yt1.start();
            yt2.start();
    	}
     
    }
    ```

    运行结果：

    第一种情况：李四（线程）当执行到30时会CPU时间让掉，这时张三（线程）抢到CPU时间并执行。

    第二种情况：李四（线程）当执行到30时会CPU时间让掉，这时李四（线程）抢到CPU时间并执行。

    sleep能保证在规定的时间内，当前线程肯定不执行。

    yield是将当前线程的运行状态终止，重新放入runnable状态。如果这时候恰好又竞争到了执行，会被立即执行。

    yield的 退让 指只会让给优先级 >= 自身的线程，如果没有比自身线程优先级高的，则会继续执行。

    

- ```
    Thread.join()
    ```

    线程加入：等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。 

    ```java
    @Test
    public void test2() throws InterruptedException {
        Thread t1 = new Thread(new MyThread2("线程3"));
        Thread t2 = new Thread(new MyThread2("线程4"));
        t1.start();
        t1.join();
        System.out.println("主线程");
    
        t2.start();
    
    }
    }
    ```

    ```
    线程3运行  :  0
    线程3运行  :  1
    线程3运行  :  2
    线程3运行  :  3
    线程3运行  :  4
    主线程
    线程4运行  :  0
    线程4运行  :  1
    线程4运行  :  2
    线程4运行  :  3
    线程4运行  :  4
    ```

    

    比如在main线程中调用了t1.join()，那么输出“主线程”的语句必须等待t1结束后才能得到cpu的执行。

    ```java
    @Test
    public void test2() throws InterruptedException {
        System.out.println("主线程");
    
        Thread t1 = new Thread(new MyThread2("线程3"));
        Thread t2 = new Thread(new MyThread2("线程4"));
        t1.start();
        t1.join();
    
        t2.start();
    
    }
    }
    ```

    ```
    主线程
    线程3运行  :  0
    线程3运行  :  1
    线程3运行  :  2
    线程3运行  :  3
    线程3运行  :  4
    线程4运行  :  0
    线程4运行  :  1
    线程4运行  :  2
    线程4运行  :  3
    线程4运行  :  4
    ```

    

​		**为什么要用join方法？**

​		在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线		程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子		线程执行完成之后再结束，这个时候就要用到join()方法了。



- ```
    Object.notify(all)
    ```

    线程唤醒：唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。

    线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。